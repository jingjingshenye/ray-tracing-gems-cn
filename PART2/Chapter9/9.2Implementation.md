如Amstutz等在[1]中讨论到的和Section 9.1中所述, 重叠的节点使得在BVH中进行无序地多重命中遍历更加复杂化了. 正确性需要实实在在地多次命中遍历来保证[5], 这可能会很慢, 或者修改BVH的结构和遍历路径, 这不仅可能会给生产环境引入潜在的开发和维护的负担, 而且根本无法与光线追踪API解耦.
为了定位这些问题, 我们介绍一下两种基于DXR的多重命中光线追踪实现算法. 简单直接地多重命中遍历和带有剔除节点的多重命中BVH遍历[3]. 我们每个算法首先实现的都是通过DXR any-hit shaders来满足每条光线多重命中的查询. 当任意一条光线在范围内[tmin, tmax], 与集合体相交, 无论其相对于其他相交点的位置如何都会触发执行DXR any-hit shaders. 这些着色器不遵循沿相交点任何预定义地执行顺序. 如果一个any-hit shader接受了一个潜在的相交点, 那么命中距离将成为光线范围的新的最大值.
我们其次为每个算法实现的内容是用DXR intersection shaders来满足多重命中查询, DXR intersection shaders能提供在用于在底层中加速的几何的替代表达. 在这种情况下, 过程化执行单元是由与坐标轴对齐的包围盒来定义的, 并且由用户定义的intersection shader将在光线与包围盒相交的时候评估这个单元. Intersection shader定义有描述相交点的属性, 包括命中距离, 然后传递给后续的着色器. 一般来说, DXR intersection shaders的效率低于内置的光线/三角形相交例程, 但是它们能提供更大的灵活性. 我们可以利用这些着色器代替DXR any-hit shaders来实现基于三角面基元的朴素的和剔除节点的多重命中光线追踪.
在这些实现中, 每个着色器假定缓冲区用于存储多重命中的结果: 一个二维的(width x height)缓冲区用于每条光线命中的计数和三维的(width x height x (Nquery + 1))缓冲区用于命中记录, 每个缓冲区都由一个命中点距离(t-value), 表面漫反射颜色和Ng·V来支持简单的表面着色操作. Any-hit shader的实现用了一个用户定义的光线有效负载结构来跟踪当前的命中数量并且需要将
D3D12_RAYTRACING_GEOMETRY_FLAGS标记为D3D12_RAYTRACING_GEOMETRY_FLAG_NO_DUPLICATE_ANYHIT_INVOCATION这意味着对于指定的光线基元相交点将禁止多次any-hit shader调用. 相应地将ray generation着色器把RAY_FLAG_FORCE_NON_OPAQUE标志设置为将所有光线/基元相交点视为非不透明. 不同的是intersection着色器的实现需要存储三角形, 顶点, 面和材质数据的缓冲区, 当使用内置的三角形原语时这些属性通常由DXR管理.
所有的着色器都依赖于着色器端的缓冲区管理工具函数, 可视化色彩映射, 等等. 同样, 每个着色器都假定控制最终渲染结果的值, 包括Nquary, 背景颜色, 和示例程序支持的用于可视化颜色映射的擦桉树. 其他DXR着色器的缓冲区最终由Falcor [2]管理, 例如二维的用于输出渲染结果的缓冲区, Falcor是我们程序中的的实时渲染框架. 为了清晰和聚焦展示的重点, 下面的实现要点中省略了这些元素.
我们的示例光线追踪程序建立在Chris Wyman的dxrTutors.Code项目[8]之上, 而dxrTutors.Code建立在Falcor之上, 用于管理DXR状态. dxrTutors.Code项目提供了高度抽象的CPU侧的C++ DXR API, 保证了快速跑通DXR程序并且能够快速进行简单的实验.

