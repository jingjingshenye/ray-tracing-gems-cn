# 摘要

本章将展示一种通过组合了光栅化渲染和光线追踪来计算全局光照的混合渲染技术。我们通过在屏幕空间中求解相交点，使用重投影（reprojection）和过滤（filtering）的方法来重用上一帧的信息，降低了每帧所需要追踪的光线数量。为了保证内存访问效率，我们将灯光存储在空间加速结构中。我们的技术在预处理阶段仅需要几秒与计算。我们原先研发了这种技术用于建筑设计效果图的实时渲染，但是它也可以被应用于其他用途。

# 概览

虽然最近 GPU 加速的光线追踪取得了很大的进展，使用统一的光线追踪算法来渲染各种不一样的大型场景同时保证可以接受的性能仍然是一个具有挑战的问题。尤其在一些场合下（并不像游戏），没有美术人员可以定义光线追踪应该需要被应用到何种程度来表现所需要的细节。我们的目标是在不做可感知的预计算的前提下，基本不对场景做任何限制，对基本静态的场景提供全局光照。

我们首先将场景渲染到 G-Buffer 中，然后从 G-Buffer 中生成光线来计算光照信息。对于每条光线，我们首先尝试在屏幕空间中进行相交测试，因为如果成功的话，这一般都会比在基于空间的数据结构中进行光线追踪快得多。除此之外，我们使用在上一帧已经完全收敛的像素来累计需要多次反射才能够计算的光照信息。另一方面，如果失败的话，我们将继续在空间数据结构中进行光线追踪，具体来说，我们使用 BVH，并同时尽量保证较高的渲染质量。图 26-1 展示了一张我们的实现所渲染的图像。

# 混合渲染方法

出于性能原因（比如可以从上一帧重用和视角无关的漫反射部分）考虑，我们分开计算高光（specular）和漫反射（diffuse）。图 26-2 展示了整个渲染管线。高光和漫反射部分的计算大体上都有以下几个步骤：
	1. 启发式光线生成：首先我们通过从上一帧获取未过滤的像素值，并通过相机运动来重投影到本帧，然后逐像素获取已经计算的光线数量，最后决定是否需要生成新的光线。
	2. 屏幕空间遍历：我们从上一帧的深度缓冲开始遍历。由于我们仅使用一个深度缓冲层，我们假设了一个厚度 t，与视场角和从现在步进的位置到相机的距离成正比，具体来说 t 由以下公式定义：
	t = d*tan(α_fov / 2) / (w*h)
	其中，α_fov 是相机的视场角，d 是像素到相机的距离，w 和 h 分别为屏幕像素尺寸。如果没有这种厚度估计，在像素边缘，如果深度梯度过大，光线将会穿过封闭的表面。对于比较高的分辨率或者较小的视场（field of view），由于深度的微分会变小，t 需要相应减小。由于没有考虑几何体的法向量，这个解决方案并不能保证非常精确。但是它在大多数情况下都足够精确。t 和屏幕分辨率之间的关系保证了它在任何分辨率和相机距离都能够准确的追踪到物体表面。
	我们不需要选择一个相对较小的厚度来防止错误的命中。在屏幕空间进行光线递进时，采样点有可能大于该位置的深度值（离相机位置更远），但是又超出了可以接受的厚度范围。在这种情况下，由于没有足够的几何体信息，我们并不认为光线命中，并立刻停止该点在屏幕空间的追踪，由于我们并不确定是否有任何在屏幕空间没有出现的几何体，所以将继续进行全空间的光线追踪。
	因为部分的光照信息是与视角相关的，所以单单从上一帧读取光照信息是不准确的。为了解决这个问题，我们存储了一个不考虑视角相关光照（高光信息）或者透明的几何体光照信息的缓冲，并暂时通过与一个常量相乘来补偿其导致的能量丢失。光线步进的结果之后被写入一个光线长度的缓冲。我们通过上一帧结果来重建采样的位置，并借此来提高之后的遍历步骤中纹理缓存（texture cache）的利用率。
	3. 遍历 BVH：我们从屏幕空间结束的位置开始继续在 BVH 中进行光线遍历，并求解辐射度（radiance）的值。我们使用一个累计缓冲（accumulation buffer）来存储所有光线所求得的辐照度的总和。如果光线没有命中，就会将天空盒的值存入累计缓冲。通过估计反射概率的分布（estimated lobe size）情况，可以从预过滤的 mipmap 中进行采样来获得一个有偏的值以降低方差。
	4. 过滤：在整合遍历结果之前，需要先应用一个基于空间（spatial）的过滤器，然后应用一个基于时间（temporal）的过滤器。

# BVH 遍历

我们客户的场景复杂度的范围很大。为了确保我们能够处理足够大的场景而仅对性能和内存使用产生合理的影响，我们的 BVH 并不包含所有场景的几何体。这意味着在任何一个时间，BVH 中只包含整个场景的一个子集，具体来说是距离相机较近的几何体。通过持续的，异步的根据相机的位置构建 BVH，几何体会根据离相机的距离，对应的加入 BVH 或者从 BVH 删除。由于我们对辐照度缓存作了基于时间的累积（temporal caching），几何体的变化基本是非常平滑的。但是对于一些缺少稳定时间积累（stable temporal accumulation）的表面（例如半透明几何体）来说，变化可能会比较明显。我们所面临的挑战是在我们性能预算之内，在 BVH 中仅选择包含对视觉效果影响最大的物体。

## 几何体的选择

为了能够选择包含相关的几何体，所有的几何体都被划分成可以单独被选择包含在 BVH 中的不同部分。这个划分可以通过物体本身的层级关系完成，但是显然对于包含较多三角形的物体需要进行进一步的划分。因此我们引入了一种自动细分的方案。首先我们为每个物体定义了一个评价函数来描述其对视觉效果的重要性 j。
j = a/(d^2) * p 
其中 a 是物体在相机视角方向上的投影面积，d 是物体相对于相机的面积。这使得第一个系数可以和其对应从相机观察该物体所对应的固体角相比较。第二个系数 p 是一个与物体相关的重要性参数，对于发光表面来说，由于缺少这些物体将会严重影响视觉效果，所以 p 大于 1，而对于不发光的表面，p 等于 1。

根据视觉重要性 j 对所有物体进行排序之后，按照不一样的效果等级，我们定义一个可以允许的性能预算以达到所期望的帧率。我们逐一加入具有最高重要性的物体直到达到我们的预算。除了几何体数量以外，开销与另一个效率参数相乘以尝试预测需要多少 AABB 相交测试才能成功相交一个几何单元（primitive）或者离开模型的包围盒。我们使用一个基于三角形网格中共享定点数量的启发式来确定这个参数。这个启发式是通过我们的经验来设计的，因为我们发现如果三角形几乎不共享顶点（比如植被这种情况），遍历的性能一般会没有那么高效。

最终我们构造了小于 10 MB 的 BVH，并能在几毫秒内将其从 CPU 上传到 GPU。这个延迟一般可以通过双缓冲来隐藏。

## 顶点处理

对于BVH 中的每一个顶点来说，我们在构造 BVH 的同时，预先计算一个单一的辐照度（irradiance）值，借此我们可以避免继续在第一次相交以后进一步遍历 BVH - 这个操作可能非常昂贵，因为光线可能会越来越不连贯（incoherent）并且因此会需要更高的计算量以及访问内存的开销。对于 BVH 中的每一个顶点来说，我们使用影响该顶点光照的所有灯光信息来计算辐照度值。我们通过向每个顶点，对每个灯光追踪一根阴影光线来进行可见性测试，来确定最终灯光的集合。当在追踪时应用这些预计算的辐射度值时，每条从 G-Buffer 像素出发会做以下简化：
	• 当追踪发生在 BVH 中时，作为一种比较粗糙的估计，我们将在光照计算中包含含有两次反射的路径。
	• 我们简化了 BVH 遍历中的着色步骤，仅计算漫反射值，并且每个点的辐照度被假定为通过重心坐标对顶点的辐照度进行平均（barycentric interpolation）所得到的值。

为了避免由于第二步所导致的太过于明显的错误，我们进一步细分三角形直到相邻两个顶点的辐照度值超过一个预设的阈值。

## 着色

为了防止一次对材质信息或者 UV 坐标的额外访问，在 BVH 中，每个三角形仅储存单一的表面颜色信息。因此纹理的颜色信息在创建 BVH 时会被平均。对于剪切蒙版（cutout mask）来说，我们计算可见的像素数量并且通过一个程序生成的剪切模式（cutout pattern）来估计整体的可见比例。这种方法可以很容易的在三角形和射线的相交测试丢弃相交结果后，在相交着色器中进行求值。虽然这些估计对于漫反射而言效果较好，缺少材质和纹理信息对于比较突出的高光部分会很明显。因此，我们针对有光泽的高光反射会对表面的颜色材质进行采样。这个模式是可选的并且对于诸如虚拟现实（Virtual reality）等需要确保更高性能的场合可以选择禁用。

整个着色过程包括对每个顶点进行对所有灯光的着色，包含阴影贴图（shadow map）的太阳光，并在最有一次光线相交处通过一个环境光的部分来补偿缺少的多次反射的结果。环境光通过读取预计算的天空盒值（基于 cosine 分布的卷积）和一个环境光遮蔽（AO）的参数。我们通过将 -d 与 k 相乘（其中 d 为光线到表面的距离，k 为人工选取的经验参数）并将其映射到指数函数上来估计 AO 的值。这等同于仅含有一次采样的半球面估计，但是这可以帮助降低在室内场景下的环境光系数以避免光照漏入场景。完整的环境光计算可以这样描述：
a = m(e^(-dk)r_skybox + r_vertex + r_sun)
其中 m 是表面颜色，r 表示各种不一样来源的辐射度。

# 漫反射光的传播

本节描述了处理漫反射和接近漫反射的间接光照。接下来的几个子节中分别解释了图 26-2 中的关键模块。图 26-4 展示了用户创建的内容的一个案例。

对于每一个材质来说，我们将出射的辐射度划分为漫反射和高光两个部分。高光部分由根据菲涅尔函数所反射的光的量来区分，而漫反射部分啧有可能进入表面并且（至少在一个简单的模型，如 Lambert 中）和视角无关。漫反射的方向分布一般会比较广，因此导致会需要更多的采样才能收敛。相反的，漫反射部分在空间中的分布更加一致，因此我们可以使用更加激进，并使用考虑更多空间中临近像素的核（kernel）来进行过滤。

## 启发式光线生成

采样方法的挑战在于我们希望可以得到一个伪随机的采样分布，借此在随后所要应用的过滤器的半径中包含尽可能多的信息。现有的离线渲染器通过最大化空间和时间采样的多样性来提升收敛的速度，如相关性多重抖动采样[9]。考虑到以下不同的情况，我们采用了一个更简单的逻辑：
	• 通常而言，针对图片中一个像素的样本并不依赖于其他图片区域的样本或者通过屏幕空间所获得之前几帧的旧样本。对于我们的情况而言，样本在多个屏幕和视角（由于重投影）进行积累，并且这些样本被在若干帧内被一一分配。
	• 光线遍历的过程相对来说比较快速，使得复杂的采样逻辑变得不具有吸引力。
	• 由于重用样本和估计光照所引入的偏差大于通过一种更先进的类蒙特卡洛方法的所能提升的。

我们首先对一个余弦分布进行采样，该分布由 64^2 个像素的平铺蓝色噪声纹理给出，每个帧交替出现一个经过Cranley Patterson旋转[2]的Halton 2, 3序列[4]。每像素所需的采样数取决于质量设置和直射光的数量。如果我们的漫反射光缓冲区的历史重投影（见26.4.2）包含的样本超过了那个数量，则不会投射新的光线。我们将依赖于视图的漫反射模型乘以依赖于法向量n和视图向量v的点积和粗糙度因子的函数，类似于预先计算的镜面DFG（Distribution，Fresnel，Geometry）项[6]。这种与视图向量的分离对于允许从不同的视图角度重用样本是必要的。

一旦我们决定查询一个新的光线，请求就被附加到一个列表中（根据图26-2中的光线队列）。然后屏幕空间遍历将使用此请求。如果我们在前一帧的深度缓冲区中找到一个有效的命中，那么结果将写入辐射累积纹理（radiance accumulation texture）（辐射缓冲区（radiance buffer））。否则，将启动全局BVH中的光线遍历。

# 基于前一帧的重投影

重投影的目的是重用以前帧中的着色信息。但是，在两帧之间，相机通常会移动，因此特定像素中包含的颜色和着色信息可能不再对该像素有效，但需要重新投影到新的像素位置。重投影仅发生在屏幕空间，不可知存储辐射度的起源（bvh或屏幕空间光线追踪）。这只能用于漫反射着色，因为它是独立于视图的。

对于成功的重投影，我们需要确定问题中的着色点（即当前处理的像素）在前一帧中是否可见；否则我们无法重投影。为了确定我们是否有可靠的颜色信息源，我们考虑了运动矢量，并检查上一帧处理的着色点的深度缓冲内容是否与运动矢量一致。如果不是，我们可能在当前位置的信息不再不一致，需要请求一个新的光线。

请求新光线的另一个原因是几何配置的改变：当相机在场景中移动时，一些曲面会改变它们与相机的距离和角度。这会导致屏幕空间中图像内容的几何失真。当重新投射漫射辐射缓冲时，必须考虑几何畸变。我们希望实现每个屏幕像素的光线密度不变，并且所描述的几何变形可以改变局部样本密度。我们存储辐射度，并预乘上我们能够积累的样本数，并使用alpha通道存储样本计数。重投影过程必须使用双线性滤波器对历史像素进行加权，并根据等式4对四个未过滤的采样都y应用失真系数b。值得注意的是这个系数可以大于等于 1，比如移动远离墙壁时。失真系数可以由下式表示：
eq（4）
其中 d 是 每个每个像素在空间中到相机的距离，v 是视图向量。

图 26-5 展示了一个场景区域，由于不一致或样本密度不足，重新投影导致光线启发式请求新光线。

## 基于 Optimized multi-pass 的时间和空间过滤

由于大量的内存读取，图像过滤器很快成为带宽限制。缓解这一问题的一种方法是在 n 个迭代中递归地对 s 个样本应用一个稀疏过滤器。影响过滤结果的有效样本量为s^n。如果这种稀疏度是随机分布的，并且种子在3×3像素窗口内变化，则可以使用邻域钳位时间滤波器(neighborhood clamp temporal filter )对结果进行过滤[7]。邻域钳位滤波器首先创建一个像素值的滚动指数平均值（rolling exponential average），并利用旧像素是新像素邻域的混合的假设来拒绝历史像素，从而避免重影。夹钳窗口可以在空间上扩展以减少闪烁[11]，虽然结果会增加重影。

 
选择提取位置是为了在保持所需半径的同时最小化冗余的读取次数。为此，我们计算了一个源像素提取位置的列表，这些位置在过滤器第n次迭代后被有效地包括进来。我们基于遗传进化的数值优化算法的损失函数是在最后3×3像素窗口中获取的重复源像素数。这确保了能够最大化时间滤波器内的样本多样性。同时，半径r应根据漫反射光线方向种子纹理的S_Seed大小而选择，以便根据r=SSeed/n来隐藏平铺瑕疵（tiling artifacts）。此半径与时间积累的3×3窗口无关，因为时间积累发生在过滤之后。通常，我们会在高斯分布中进行加权，根据样本的距离来模拟附近样本的相关性。在multi-pass的方法中，这是不必要的，因为对圆形内核进行迭代采样会产生适当的非线性衰减，而不会影响外部内存读取（见kawase[8]的文章）。没有一个读取使用了硬件的纹理过滤来确保来自我们的源缓存的离散深度和法向量的权重。之后就可以使用来着 G-Buffer 的法向量和视图空间的深度来缩放双边权重（bilateral weight ），类似于Dammertz等人的技术[3]。图26-6比较了我们与Schied等人的multi-pass方法[12]。

# 光照高光部分的传播

与漫反射过滤不同，高光部分的过滤在反射中很容易在视觉上模糊细节。我们必须仔细挑选和权衡合并的样本，以估计镜面反射瓣。在Stachowiak[13]的启发下，我们以半分辨率追踪高光光线，然后使用比率估计器解析为全分辨率。由此引入的偏差是可以接受的，并且估计量能够保持法线贴图的细节和粗糙度变化。主要的挑战仍然是在高方差一些情况下（如粗糙的金属表面）减少噪音，同时尽可能减少偏差。在采样过程中，我们只需要对微表面的分布项进行采样，菲涅耳函数和几何函数由查找表[6]近似。

## 时间累积
与漫反射过程类似，我们试图通过将像素的位置重新投影到以前高光反射缓冲中来查找像素的历史。这是通过使用Stachowiak[13]和Aizenshtein[1]的虚拟光线长度校正技术完成的。为了避免硬件双线性滤波造成的错误，我们必须分别计算四个双线性样本的权重，并跟踪总权重。当重新投射完全失败时，比如一些空洞（disocclusion），我们只能使用新的超采样的结果。我们使用一个3×3高斯模糊版本的具有非线性的超采样缓冲器，如感性量化器光电传递函数（perceptual quantizer electro-optical transfer function）（在高动态范围视频信号处理中用作伽马曲线），来隐藏噪点（fireflies）。

基于方差的邻域钳位时间滤波允许我们丢弃不正确的重投影（reprojection）。但是，如果目标辐射偶尔不是本地 YCoCg 包围盒的一部分，则会发生闪烁。这可以通过对高光波瓣（specular lobe）添加偏差[13]，在时间积累后应用基于方差的滤波器[14]，扩大邻域的空间大小，或者简单地变暗引入偏差的亮像素来解决。我们观察到闪烁主要是由一个在时间上不稳定的最大亮度分量引起的。因此，我们选择暂时平滑产生的色卡的最大亮度。这只需要存储一个额外的值，并且几乎不会产生副作用。

## 重用漫反射波瓣（diffuse lobe）
高光的计算发生在漫反射之后，由于以下两个原因，我们决定在高光计算中重用过滤后的漫反射结果：
> 作为粗糙导电体的高光波瓣在低方差情况下的回退值：使用漫反射波瓣作为高光反射波瓣的近似值是不准确的。然而，因为波瓣能量在一个相似的范围内，这在视觉上是合理的。这可以在对视觉效果造成较小的影响的情况下，提高性能。对于金属，我们不能依赖于这种简化，因为反射分量的贡献太明显。
> 作为几何体在反射中的全局光：当我们不希望进一步的在命中点进行追踪并收集入射光，我们需要假设一个全局光的分量。反射表面的漫反射光照被证明是一个便宜却又很好的估计。

## 基于路径追踪的间接光照
对于类似镜面的材质来说，添加基于路径追踪的间接光照是必须的。由于这种方法需要对内存进行许多随机访问并且采样结果有很高的方差，所以是非常昂贵的。Liu[10] 提出可以在过滤间接漫反射分量的同时过滤镜面材质的间接漫反射分量。正确分离过滤后的材质颜色（albedo）和直接光照将需要为反射存储和获取多个额外的缓冲。然而我们选择在最后整合阶段根据随机种子材质的大小（我们采用了 5x5）来进行过滤，并同时利用色调映射所求的均值（ton-mapped average）来减少噪点（fireflies）。这是一个双边（bilateral）滤波器，并同时考虑了反射射线的长度和法线 G-Buffer 来保持几何体在反射中的轮廓以及法线贴图的细节。为了使得整体过程不过与太昂贵，这种特殊的过滤以及对间接漫反射的过滤仅应用于高粗糙度的金属表面上。在不发射额外光线的情况下，一种比较快速的方法是通过将环境光分量与基于光线长度（可以理解为虚拟屏幕的深度）的 SSAO 分量相结合。

## 估计波瓣的足迹（lobe footprint estimation）
类似于 Liu 的工作[10]，我们根据反射波瓣足迹在屏幕空间中投影的尺寸来调整过滤需要的提取（fetch）数量。这个可以通过计算一个二维缩放矩阵的维度来实现。

由于大多数的表面并非平面，我们也需要估计局部的曲率来对应的调整足迹。这个通过对 G-Buffer 法线进行局部求导实现。我们根据二维波瓣畸变矩阵的特征向量选择邻域，该矩阵描述了投影到屏幕空间单元的切向空间中波瓣的伸长和收缩。两个相邻点的最小导数用于避免几何边缘的瑕疵。最后，样本数与矩阵的行列式成正比。如果滤波器的大小小于追踪的分辨率的√2倍，我们将切换到固定的3×3像素内核。这确保了我们在半分辨率追踪弯曲（或正常映射）光泽表面时考虑所有的邻居，以提高重建的质量。这在下面的代码中进行了总结。

# 半透明物体

为每个像素存储所有的 alpha 记录，但是会增加内存的用量。由于我们不想这样做，半透明表面的反射变得更加复杂。我们主要通过 TAA 来处理随机噪声。因为我们家是大多数半透明的表面（比如玻璃）具有很低的粗糙度因而并不会受到由于对高光分布进行重要性采样而导致的高方差问题。我们将带有 alpha 的像素在着色前根据层进行排序，使得每个层使用不一样的质量设定。和所有不透明物体的高光分量一样，我们仅追踪半分辨率大小。但是和高光相反，我们没有 G-Buffer 的信息，因此我们无法使用相同的超采样算法。我们通过在回复全分辨率的过程中，利用蓝噪声对每个像素进行偏移，实现了一种时间空间的扰乱（shuffle）。这可以被认为是只需要一次读数据的模糊滤镜。和 TAA 结合以后，我们就可以用缺少采样导致的错误来代替噪音。

# 性能

我们使用 NVIDIA Titan V 硬件，在分辨率 1920*1080 来衡量性能结果。现在的实现仍然使用自制的着色器来处理遍历，而不是 DirectX Raytracing 等方案。如图 26-7 所示，场景中包含 1500 万个多边形，是建筑场景中常见的数量。渲染每帧所需要的时间持续低于 9 毫秒。

表 26-1 展示了在默认质量设定下，不同部分在实时情况下所花费的时间。同时，还有一些系统参数可以针对诸如图像或者视频等用来提升画面质量使其更加真实。或者针对虚拟现实等由于注重体验和帧率的场合进行调整以取得更好的性能。除了一些常见的参数如采样数，光线反弹次数，滤镜内核尺寸，BVH 中几何体的数量以外，我们发现调整光线的最大长度和从高光回退到漫反射的阈值(26.5.2)也是在各种应用场合下平衡质量和性能的方式。

## 用于虚拟现实的沉浸式渲染（stereo rendering）

对于 VR 来说，我们选择其中一只眼睛作为主要的视角，并在每一帧切换到另一个眼睛。对于主要的视角来说，我们更新漫反射光照。上一帧的信息通过重投影漫反射和高光 G-Buffer 的方法被应用于另一个视角。但是这种方法有一些瑕疵。相机移动时会因为几何体的遮挡导致孔洞。由于采样的随机性，不同视角积分结果的不一致性由于沉浸式头戴设备而变得明显。这种差异性也可能来源于在相同的场景坐标上使用了不同的采样种子。为了应对这两种问题，我们重投影主要视角最新更新的信息，并在之后与另一只眼睛所取得的信息通过一个平均参数 γ 进行加权平均。如果该视角在上一帧的信息完全无法使用但是我们有成功的重投影信息，则 γ = 1。

而对于漫反射光线的启发式，我们增加屏幕中央像素的采样密度。而对于相对靠外的区域，在重投影之后，采样密度甚至可能低于 1 ，这在大多数的情况下也是可以接受的。我们使用这种中心凹进法（forveation approach）使我们能最有效的利用计算资源。

## 讨论
我们所描述的全局光照算法能够在不同的性能要求下伸缩。它能通过多次反射光线来输出高质量的图像，也能通过另一套不一样的参数和几乎相同的代码来达到更低的渲染时间从而应用于 VR。诸如基于后处理的景深，动态模糊等一系列基于 G-Buffer 的技术仍然有效并且更快。除此之外，阴影映射（shadow mapping）也可以通过光线追踪来提升。使用光线追踪来替换所有阴影银蛇仍然具有性能上的挑战，但是它已经保证可以提供非常高质量的结果了[5]。

受限于我们通过体积纹理来估计次表面散射现象的计算方式，需要混合多层半透明的场合下光线追踪反射的伸缩性也具有提升的空间。而对于漫反射和高光的积分，我们希望能够给使高光漫反射受益于光线启发式，而不是所有屏幕区域在每帧都进行相同次数的采样。

声明
我们感谢 Tomasz Stachowiak 和其他编辑对本文的宝贵建议和更正。




















