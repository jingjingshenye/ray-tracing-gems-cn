基于光子映射的全局光照
摘要
间接照明其实也可以说是全局照明，如果想要实现照片级的效果全局照明必不可少。 虽然有许多基于预计算的有效全局照明技术适用于静态场景，但是场景中如果有动态光照以及动态几何体，这种情况下想要实现全局光照的挑战性非常大。 在本章中，我们描述了一种基于光子映射的实时全局照明算法，该算法在动态光照和完全动态几何体的场景中评估几次间接照明的，而没有任何预先计算的数据。这一章介绍了在有限的实时帧率范围内实现动态高质量照明所需的预处理和后处理步骤。
24.1 介绍
随着图形硬件技术的不断发展以及实时图形可能实现的范围不断扩大，场景也变得越来越复杂和动态。现有一些实时全局照明算法（例如lightmap、lightprobe）都需要依赖于预先计算的数据，这样对于移动的灯光和几何体并不能很好地工作。
在本章中，我们描述了一种基于光子映射实现的方法[7]，一种蒙特卡罗方法，首先跟踪场景中光子的路径创建表示间接照明的数据结构，然后使用该数据结构估计阴影点处的间接光用来实现近似光照。请参见图24-1。光子映射具有许多有用的属性，能够与预计算的全局照明很好的兼容，提供与当前静态技术具有相似质量的结果，可以轻松地折衷质量和计算时间，并且不需要重要的艺术家工作。我们的光子映射实现基于DirectX光线跟踪（DXR），并通过动态场景提供高质量的全局照明。我们方法的总体结构如图24-2所示。
如果想让光子映射技术适应于GPU上的实时渲染需要解决许多挑战。 一个是如何在场景中阴影处找到附近的光子，这样光子就可以为这些位置提供间接照明。 我们发现一种基于splatting的方法，其中每个光子基于其贡献的程度被光栅化到图像中，效果很好并且可以直接实现。
另一个挑战是传统的光子映射算法可能无法在实时渲染计算有限制的情况下达到所需的照明质量。因此，我们使用反射阴影贴图（RSM）[2]优化光子的生成，以避免追踪光线的第一次反射，用光栅化代替该步骤。然后，我们可以将重要性采样应用于RSM，更频繁地选择具有高贡献的位置以生成后续光子路径。
最后，与将蒙特卡罗技术应用于实时渲染时一样，有效滤波对于消除由于采样次数较少而导致的图像锯齿至关重要。 为了减轻噪声，我们使用具有指数移动平均值的时间累积，并应用边缘感知空间滤波器。
24.2 光子追踪
一般的光线跟踪对于跟踪从表面反射的光子的路径是必要的，首先要明白这样一个事实，那就是离开单点光源的所有光子具有共同原点，接下来可以利用这个特征。在我们的实现中，每个光子路径的第一段是通过光栅化处理实现。对于每个发射器，我们生成反射阴影贴图（RSM）[2,3]，它实际上是从光源这个方向看到的可见表面的均匀样本的G-buffer，其中每个像素还存储入射照明。 这种基本方法由McGuire和Luebke [10]十年前提出来的，他们在CPU上跟踪光线，性能表现非常差，而且还需要在CPU跟GPU之间传递有效的数据（这些在DXR的实现中都不在需要）。
在通过光栅化找到初始交叉点之后，后续的光子路径通过对表面的BRDF进行采样并跟踪光线来继续。光子存储在所有后续的交叉点中，用于重建照明，在24.3节中将会详细讲述。
24.2.1基于RSM第一次BOUNCE
我们首先从所有光源中选择要发射的光子总数，然后将这些光子分配给与每个光强度成比例的光。 因此，所有光子最初都携带大致相同的功率。 RSM必须包含为光子的初始反射生成光线所需的所有表面属性。
生成传统ShdowMap后使用单独一个Pass继续生成RSM。这样做允许我们使RSM映射的分辨率独立于阴影贴图并保持其大小不变，从而避免在运行时分配RSM。作为优化，可以使用常规阴影贴图进行深度剔除。如果没有匹配的分辨率，这将为某些像素提供不正确的结果，但在我们的测试中，我们没有发现它会导致可见的伪像。
生成RSM之后，我们生成用于对第一次反弹的起始点进行采样的重要性图，其中每个RSM像素首先根据光子所承载的发射功率的乘积的亮度给出权重，包括美术可以控制的参数，例如方向衰减和表面反射。该权重值与离开表面的光子携带的功率量直接相关。
这种重要性图不是标准化的，这是大多数采样技术所必需的。我们不是对贴图进行标准化并生成采样分布，而是应用基于小波重要性采样的分层采样算法，由Clarberg等人引入[1]。
小波重要性采样有两个重要步骤。首先，我们将离散Haar小波变换应用于概率图，有效地生成图像的金字塔表示。其次，我们以低差异序列重建每个样本位置的信号，并基于小波变换中每次迭代的缩放系数来扭曲采样位置。这种变形方案如图24-3所示。有关它的更多信息，另请参见第16章“Sampling Transformations Zoo”。
必须在整个图像金字塔上应用小波变换，每步的分辨率减半，知道最终的分辨率为2x2。 为这么小的维度使用单个计算着色器Pass是低效的，我们对内存最后一级的使用单独执行Computer shader pass，这是一种标准的简化实现。
重要性采样将低差异样本转换为RSM中具有相关概率的样本位置。换言之，可以使用重要性采样找到出射光线的方向。被采样的光线使用表24-1中给出的格式表示。 因为每个样本独立于其他样本，所以除了在输出缓冲区中分配位置的原子计数器之外，不需要在样本点之间进行同步。但是，我们必须使用采样索引在此阶段为随机数生成器生成种子，而不是稍后使用样本缓冲区位置在光子跟踪中生成种子，这样做可以使光子路径在帧之间保持确定性。
通过使用重要性采样来选择被跟踪光子的RSM中的像素，我们能够选择这些光子功率跟频率都比较高的像素。这样可以让光子的功率变化比较小。RSM的另一个优点是它们可以轻松地从一个RSM点跟踪多个光子路径，为每个光子路径选择不同的方向。当所需的光子数量与RSM的分辨率相比变高时这样做尤为有效。
24.2.2跟随光子路径
从采样的RSM点开始，然后在每个后续的光子与表面交叉点处，我们使用重要性采样生成输出方向ω，采样分布p（ω）类似于表面的BRDF。例如，我们对漫反射表面使用余弦加权分布，我们对微平面BRDF的可见微平面分布进行采样[5]。
在追踪反射光子之前，我们应用俄罗斯轮盘（Russian roulette），根据BRDF时间（ω.ωg）与采样方向概率之间的比率随机终止光子。在此测试中存活的光子会相应地调整其输出，以使最终结果正确。以这种方式，当光线遇到反射很少光的表面时，与表面反射大部分入射光相比，光子的持续时间更少。就像根据发射功率将光子分配到光源一样，这也可以通过确保所有实时光子具有大致相同的输出来改善结果。
由于光子的功率具有多个通道（在RGB颜色模型中），因此可以修改俄罗斯轮盘测试，使其完成一次，而不是每个通道。 我们选择使用Jensen [7]描述的解决方案来处理这个问题，将终止概率设置为
 
其中q是标量终止概率，Φi是光子的输入功率，ρ是BRDF乘以（ω⋅ωg）和散射方向概率密度函数（PDF）之间的比率。 然后，输出光子功率是Φi乘以ρ除以p，具有分量乘法。
我们不是每帧使用相同的随机样本，而是每次都使用新的随机种子。这导致跟踪的光子的路径对于每帧都会有相应的变化，从而提供不同的样本集并且导致在多个帧上累积较大的样本集。
光子存储在一个数组中，其中通过原子递增全局计数器来分配条目。由于我们的目的是仅计算间接照明，因此我们不会为RSM中的初始光子与表面交叉点存储光子，因为它代表直接照明，使用其他技术（例如，阴影贴图或跟踪阴影光线）可以更好地处理。我们也不会将光子存储在法线远离相机的表面或位于相机平截头体外部的光子，这两种类型都不会影响最终图像。请注意，我们的视锥体剔除仅将光子视为点并忽略其覆盖的半径范围。因此，实际上有助于辐射估计的平截头体边缘处的一些光子被错误地剔除。这个问题可以通过扩展用于剔除的相机平截头体来解决。但是，当屏幕空间中的内核大小足够小时，此错误似乎不会导致任何明显的视觉瑕疵。
每个光子表示为32个字节，如表24-2所示。
24.2.3 DXR的执行
使用DXR实现光子跟踪非常简单：为所有已采样的RSM点启动光线生成着色器，使用每个RSM点作为后续光子射线的起点。然后它负责跟踪后续光线，直到达到最大反弹次数或俄罗斯轮盘终止路径。
两个优化对性能很重要。第一个是最小化射线有效载荷的大小。我们使用32字节光线有效载荷，使用16位float16值和RGB光子功率编码光线方向作为32位rgb9e5值。有效载荷中的其他字段存储伪随机数发生器的状态、光线的长度、反射的次数。
第二个关键优化是移动用于采样新射线方向的逻辑并将俄罗斯轮盘赌应用于最近命中的着色器。这样做可以通过降低寄存器压力显著提高性能。我们给光线生成的shader代码如下所示：
 
 
最近命中的着色器从光线有效负载中解包所需的值，然后确定接下来要跟踪的光线。 即将定义的validate_and_add_photon（）函数将光子存储在已保存光子数组中（如果它对相机可能是可见的）。
 
最后，如前面第24.2节所述，存储的光子被添加到线性缓冲区，使用原子操作来分配条目。
 
24.3屏幕空间辐照度估计
给定光子数组，下一个任务是使用它们来重建图像中的间接照明。每个光子都有一个与之相关的内核，它代表了它可能贡献的场景（以及图像）的范围。我们的任务是累积每个光子在每个像素处的贡献程度。
已经将两种通用方法应用于该问题：聚集和散射。聚集本质上是像素上的循环，其中在每个像素处使用空间数据结构找到附近的光子。散射本质上是光子上的循环，其中每个光子对其重叠的像素有贡献。见Mara等人[9]全面概述了实时聚集和散射技术。鉴于现代GPU上的高效光线跟踪以生成光子图，重建效率也很重要。我们的实现基于散射并且利用光栅化硬件有效地绘制splatting内核。使用混合累积结果。
我们使用光子来重建辐照度，这是到达某一点的光的余弦加权分布。然后，我们使用平均进入方向近似光子的辐照度和表面BRDF的乘积从表面反射的光。在这里丢弃了间接照明的方向分布，并避免对影响点阴影的每个光子的反射模型进行重要的评估。这为漫反射表面面提供了正确的结果，但随着表面变得更加光滑并且间接光照的分布变得更加不规则，它会引入误差。在实践中，我们没有从这种近似中看到令人反感的错误。
24.3.1定义SPLATTING内核
为每个光子选择一个好的内核大小很重要：如果内核太宽，则光线会过于模糊，如果它们太窄，则会出现斑点。避免太宽的内核尤为重要，因为更宽的内核会使光子覆盖更多的像素，从而导致光子的光栅化、着色和混合工作更多。光子映射的内核选择不正确会导致几种类型的偏差和错误[14]; 最小化这些已成为大量研究的焦点。
在我们的方法中，我们从球形内核开始，然后对其应用许多修改，以便最小化各种类型的错误。这些修改可以分为两种主要类型：统一缩放和修改内核的形状。
24.3.1.1内核的统一缩放
内核的均匀缩放是两个项的乘积，第一个基于光线长度，第二个基于光子密度分布的估计。
光线长度 我们根据光线长度使用线性插值将内核缩放到恒定的最大长度。 该方法是射线差分的近似，并且可以解释为将光子视为沿着锥体而不是射线行进并且随着其高度增加而考虑锥体基部的生长。此外，随着光线长度的增加，我们可以假设光子密度较低，因为光子可能会散射到更大的世界空间体积。 因此，在这种情况下，我们需要一个相对宽的内核。 缩放因子是
 
其中l是光线长度，lmax是定义最大光线长度的常数。然而，lmax不需要是在光子追踪期间投射的光线的最大长度，而是我们认为是锥体的最大高度的长度。此常量应与场景的整体比例相关，并且可以从其边界框导出。
光子密度 我们希望根据光子周围的局部光子密度进一步缩放每个光子的内核：附近的光子越多，内核可以（也应该）越小。挑战在于有效地确定每个光子附近有多少光子。我们应用为每个屏幕空间图块维护计数器的简单近似。当光子沉积在图块中时，具有光子映射的计数器实时全局照明以原子方式递增。这显然是密度函数的粗略近似，但它似乎产生了相当好的结果。
然后，我们实现基于密度的缩放作为视图空间中图块区域的函数：
 
其中αx和αy是相机平截头体的光圈，zview是相机的距离，tx和ty是以像素为单位的平铺尺寸，rx和ry代表图像的分辨率。在大多数情况下，块区域的深度不均匀，因此我们使用光子位置的深度。大多数算法都可以预先计算并用相机常数替换：
 
因此，缩放圆形内核以在视图空间中具有与区块相同的区域可以被计算为
 
其中np是瓷砖中的光子数。该值被clamp以去除任何极端情况，然后乘以常数ntile，其等于我们期望对每个像素贡献的光子数：
 
这些方程的HLSL实现很简单：
 
24.3.1.2调整内核的形状
我们可以通过调整内核的形状来进一步改善重建结果。我们考虑两个因素。首先，我们在光子相交的表面法线方向上减小内核的半径。其次，我们在光的方向上缩放内核，以便对其覆盖在表面上的投影区域进行建模。这导致核是三维的椭球，其中有一个轴n，代表法线的方向ωg。另外两个轴放置在由光子法线定义的切平面上，称为内核平面。两者中的第一个u，具有投射到核平面上的ωi的方向；而第二个t，与u正交并且在同一平面中。 该向量基础如图24-4所示。
n的大小是snslsd，其中sn是一个常数，它沿着法线压缩内核，使其更接近表面。这是一种常见的方法：它由Jensen [7]完成，用于收集不同的聚集半径和与球形核相比，这提供了更好的表面近似。但是，如果内核被压缩太多，则具有复杂形状或重要表面曲率的对象上的分布变得不准确，因为内核忽略远离其平面的样本。这可以通过使幅度成为表面曲率的函数来补偿，但是在我们的执行过程中，该因子是恒定的。
u的大小是suslsd，其中su被定义为命中法线和光线方向之间角度的余弦的函数：
 
其中smax是定义最大比例因子的常数。当ωg和ωi之间的角度减小到零时，幅度将接近无穷大。该方程的起源于光线差分和光子的锥形表示：当光子的入射方向变得与表面的法线方向正交时，投射到核平面上的锥体底部的面积增加。
最后，t的大小是slsd。
以下代码显示了形状修改的实现：
 
24.3.2光子发射
我们使用二十面体的实例间接绘制作为球体的近似来绘制光子。（绘制调用的间接参数是使用validate_and_add_photon（）函数中的原子计数器设置的。）为了应用上一节中介绍的内核形状，我们相应地转换顶点着色器中的顶点。 由于原始内核是一个球体，我们可以假设内核的对象空间的坐标框架是世界空间的坐标框架，因此顶点位置为
 
我们为我们的splatting内核保留像素着色器尽可能简单，因为它很容易成为性能瓶颈。 它的主要任务是深度检查，以确保我们计算辐射的G缓冲区表面在内核中。深度检查作为对表面和内核平面之间的世界空间距离的剪切操作与由内核压缩常数缩放的常数值完成。 深度检查后，我们将内核应用于splatting结果：
 
其中a是椭圆的面积，a =π‖u‖‖t‖=π（slsd）（slsdsu）。值得注意的是，此处的辐照度由余弦项缩放，因此隐含地包括来自几何法线的信息。
为了积累辐照度，我们使用半精度浮点格式（每个通道）以避免低位格式的数值问题。 此外，我们将平均光方向累加为半精度浮点数的加权和。 第24.4.3节讨论了存储方向的动机。
以下代码实现了splatting。 它使用先前定义的两个函数来调整内核的形状。
 
如前所述，我们使用附加的混合来积累光子的贡献。现代图形API保证像素混合以提交顺序发生，尽管我们在这里不需要此属性。作为替代方案，我们尝试使用栅格顺序视图，但发现它们比混合慢。使用浮点原子内在函数（在NVIDIA GPU上作为扩展可用）确实可以在屏幕空间中许多光子重叠的情况下提高性能（这是焦散的常见场景）。
24.3.2.1使用降低的分辨率优化散射
Splatting可能是一个性能消耗非常大的过程，尤其是在渲染高分辨率图像时。将图像分辨率降低到原始渲染分辨率的一半并不会导致最终结果的视觉质量明显下降，并且显着提高了性能。使用较低分辨率确实需要更改像素着色器中的深度裁剪以消除曲面之间的辐照度渗透：用于模板绘制的半分辨率深度模板应使用距离相机最近的像素缩小，但像素着色器中使用的深度应使用相机中最远的像素缩小剪裁。因此，我们仅为那些完全在全分辨率内核中的像素绘制splatting内核。 这会在splatting结果中产生锯齿状边缘，但是通过过滤将其移除。
24.4滤波
作为实时蒙特卡罗渲染方法的典型，有必要应用图像滤波算法来补偿低样本数。虽然近年来在去噪方面取得了重大进展，但光子分布核引起的噪声与路径跟踪所表现出的高频噪声有很大不同，而且一直是去噪工作的主要焦点。因此，需要不同的解决方案。
我们使用具有基于几何的edge-stopping函数的样本的时间和空间累积。我们的方法基于Dammertz等人以前的工作[4]和Schied等人[13]，我们的实现使用edge-avoiding À-Trous小波变换进行空间滤波。由于间接照明通常是低频率，我们考虑以较低分辨率进行滤波以降低计算成本，但我们遇到了由于G缓冲区差异而导致的伪像，因此在最终分辨率下还原为滤波。
我们的时间和空间滤波算法都使用基于两个像素之间的深度差异和它们的表面法线差异的edge-stopping函数。 这些功能基于Schied等人的实现[13]，尝试通过基于两个不同像素p和q的实时全局光照和光子映射表面属性生成权重来防止跨越几何边界的滤波。 深度差权重wz由下式定义
 
其中z（P）是像素位置P处的屏幕空间深度，并且∇z（P）是深度梯度矢量。 经过实验，发现σz= 1效果很好。
接下来，正常差重wn考虑表面法线的差异：
 
我们发现σn= 32才能正常工作。
24.4.1时间滤波
时间滤波通过累积先前帧的值来改善图像质量。它通过使用速度矢量重新投影前一帧的滤波辐照度值来实现，然后在每个像素p处计算前一帧的重新投影过滤的辐照度值Ei -1（P）与使用计算splatting的辐照度值Ei（P）之间的指数移动平均值，给出时间过滤的辐照度Ei（P）：
 
这是卡里斯用于辐照度的时间抗锯齿（TAA）方法[8]。
使用α的常数值会导致严重的重影瑕疵，因为时间滤波不会考虑去除遮挡、移动的几何体或移动的灯光。因为像素处的辐照度值Ei可以在帧之间显著变化，所以TAA中使用的颜色空间限幅方法不适合它们。我们依赖基于几何的方法，并使用edgestopping函数定义α
 
其中P是当前像素样本，Q是来自前一帧的投影样本。要评估权重函数，必须保持前一帧的G缓冲区的正常和深度数据。 如果splatting目标的分辨率低于滤波目标，我们使用双线性采样在时间滤波通道开始时放大splatting结果。
24.4.2空间过滤
边缘避免Á-Trous小波变换是一种multi-pass滤波算法，在每个步骤i具有增加的内核占位面积Ωi。 这在图24-5中的一个维度中说明。注意，滤波器头部的间隔在每个阶段加倍，并且滤波器头部之间的中间样本被忽略。因此，滤波器可以具有大的空间范围，而不需要所需的计算量的过度增长。该算法特别适用于GPU实现，其中组共享存储器可用于在评估内核的不同像素之间有效地共享表面属性。
我们的方法沿用Dammertz等人[4]和Schied等人[13]的方法，其中我们将每次迭代实现为5×5交叉双边滤波器。有效样本通过函数w（P，Q）加权，其中P是当前像素，Q是滤波器内的有效样本像素。第一次迭代使用时间滤波的辐照度值
 
然后每个后续级别过滤前一个级别：
 
24.4.2.1方差裁剪细节系数
为了避免过度模糊，重要的是基于图像内容的准确性来调整图像过滤。例如，Schied等人[13]使用方差估计作为其权重函数的一部分。 这适用于高频噪声，但不适合光子映射的低频噪声。我们开发了一种新的滤波算法，该算法基于Á-Trous变换各阶段之间差异的方差裁剪。
静态小波变换（SWT）最初是为了解决离散小波变换的一个缺点而引入的，即变换不是移位不变的。 通过为每次迭代保存每个像素的细节系数来解决该问题。 细节系数可以定义为
 
这使得SWT本身就是多余的。如果我们考虑如何重建原始信号，我们有
 
其中n是迭代次数。我们可以看到，为了重建原始信号，我们只需要细节系数的总和。 这样做可以让我们将所需的内存量减少到两个纹理，每个纹理都具有原始图像的分辨率。 然而，这只是让我们处于我们开始的同一点——原始未经过滤的图像。
但是，在将它们添加到总和之前，我们可以对每个细节系数应用方差裁剪[12]。 这种方法在这里很有效，与未经过滤的帧辐照度值Ei不同，因为我们从时间滤波的值开始。我们基于空间核内的辐照度的方差来计算颜色空间边界（由bi表示）。反过来，这些边界用于剪切细节系数，我们计算最终过滤的辐照度值为
 
最后，我们将过滤后的辐照度应用于曲面。 如前所述，我们忽略间接照明的方向分布。 相反，我们使用平均方向作为入射光参数来评估BRDF。辐照度乘以检索到的BRDF值：
 
图24-6说明了我们方法的各种过程。
24.4.3考虑正常阴影的影响
光子映射包括方向信息作为辐照度计算的隐含部分，因为具有指向入射光方向的几何法线的表面具有被光子击中的更高概率。但是，此过程不会捕获材质属性（例如法线贴图）提供的细节。这是一个众所周知的预先计算的全局照明方法的问题，并且有几种方法可以解决它[11]。为了实现可比较的照明质量，我们还必须考虑光子映射这一因素。
我们开发了一个受Heitz等人启发的解决方案[6]：我们将光方向ωi过滤为单独的一项。 然后，当计算辐照度时，我们有效地从该方向ωi的点积中除去原始余弦项与几何法线ωng，并将其替换为ωi和阴影法线ωns的点积。这将公式19更改为
 
其中ωi是光方向的加权平均值，而smax是第24.3.1.2节中使用的最大比例因子。
以这种方式考虑表面法线会带来性能成本，因为它需要额外的splatting混合目标，以及每个过滤步骤的额外输入和输出。但是它允许我们在计算辐照度时应用法线贴图中的信息而不读取G缓冲区法线。
过滤BRDF而不仅仅是光方向可以获得更精确的镜面表面结果。但是这样做需要在辐照度估算期间评估BRDF，从而读取材料属性。当使用splatting实现时，这将带来显着的性能成本，因为必须为每个像素着色器调用读取G-buffer。基于计算着色器的收集方法可以通过仅加载材料属性一次来避免此问题，尽管它仍然会支付评估BRDF的计算成本。
24.5结果
我们通过三个场景评估了我们的方案：会议室（如图24-7所示），Sponza（图24-8）和3DMark Port Royal（图24-9）。会议室有一个光源，Sponza有四个，Port Royal有一个来自无人机的聚光灯，另一个指向相机。 Port Royal场景的渲染包括光子功率的艺术倍增，以加强间接照明效果。
表24-3报告了具有高质量设置的这些场景的计算时间（以毫秒为单位）：1080p分辨率，300万个初始光子，3次间接光反射和4个空间滤波器迭代。使用NVIDIA RTX 2080 Ti测量结果。请注意，对于所有场景，最昂贵的阶段是splatting。过滤所花费的时间对于所有场景大致相同，因为它独立于场景的几何复杂度，但是是图像空间操作。
在表24-4中，我们检查了改变一些参数的影响。正如预期的那样，在RSM中追踪光线和光子splatting花费的时间随着追踪的光子数量而增加。由于俄罗斯轮盘的路径终止，增加反弹次数会降低性能，而不是增加相应数量的初始光子。增加图像分辨率相应地增加了splatting和过滤时间。
24.6未来工作
在许多方面，可以改进这里描述的方法的性能或质量。
24.6.1忽略splatting过程优化辐射分布
使用高密度函数时，splatting内核的屏幕空间大小可以接近像素的大小，这使得绘制splatting内核变得浪费。这可以通过将辐照度值直接写入帧缓冲而不是splatting来解决。
24.6.2用于方差裁剪细节系数的自适应常数
不幸的是，我们无法确定辐照度的变化是由低样本数量还是照明条件的实际差异引起的。 通过分层抽样提供的较大样本集可以在一定程度上缓解这种情况。当使用时间滤波累积这些样本时，在时间样本被拒绝的情况下噪声变得可见。因此，对于这些区域，最好使用较少的收缩方差限幅边界。可以通过基于我们用于定义时间样本的累积的权重来缩放方差限幅常数来实现这样的系统。

参考
[1] Clarberg, P., Jarosz, W., Akenine-Möller, T., and Jensen, H. W. Wavelet Importance Sampling: Efficiently Evaluating Products of Complex Functions. ACM Transactions on Graphics 24, 3 (2005), 1166–1175. 
[2] Dachsbacher, C., and Stamminger, M. Reflective Shadow Maps. In Proceedings of the 2005 Symposium on Interactive 3D Graphics and Games (2005), pp. 203–231. 
[3] Dachsbacher, C., and Stamminger, M. Splatting Indirect Illumination. In Proceedings of the 2006 Symposium on Interactive 3D Graphics and Games (2006), ACM, pp. 93–100. 
[4] Dammertz, H., Sewtz, D., Hanika, J., and Lensch, H. Edge-Avoiding À-Trous Wavelet Transform for Fast Global Illumination Filtering. In Proceedings of High-Performance Graphics (2010), pp. 67–75. 
[5] Heitz, E., and d’Eon, E. Importance Sampling Microfacet-Based BSDFs using the Distribution of Visible Normals. Computer Graphics Forum 33, 4 (2014), 103–112. 
[6] Heitz, E., Hill, S., and McGuire, M. Combining Analytic Direct Illumination and Stochastic Shadows. In Proceedings of the ACM SIGGRAPH Symposium on Interactive 3D Graphics and Games (2018), pp. 2:1–2:11. 
[7] Jensen, H. W. Realistic Image Synthesis Using Photon Mapping. A K Peters, 2001. 
[8] Karis, B. High-Quality Temporal Supersampling. Advances in Real-Time Rendering in Games, SIGGRAPH Courses, 2014. 
[9] Mara, M., Luebke, D., and McGuire, M. Toward Practical Real-Time Photon Mapping: Efficient GPU Density Estimation. In Proceedings of the ACM SIGGRAPH Symposium on Interactive 3D Graphics and Games (2013), pp. 71–78. 
[10] McGuire, M., and Luebke, D. Hardware-Accelerated Global Illumination by Image Space Photon Mapping. In Proceedings of High-Performance Graphics (2009), pp. 77–89.
[11] O’Donnell, Y. Precomputed Global Illumination in Frostbite. Game Developers Conference, 2018. Real-Time Global Illumination with Photon Mapping 436 
[12] Salvi, M. An Excursion in Temporal Supersampling. From the Lab Bench: Real-Time Rendering Advances from NVIDIA Research, Game Developers Conference, 2016. 
[13] Schied, C., Kaplanyan, A., Wyman, C., Patney, A., Chaitanya, C. R. A., Burgess, J., Liu, S., Dachsbacher, C., Lefohn, A., and Salvi, M. Spatiotemporal Variance-Guided Filtering: Real-Time Reconstruction for Path-Traced Global Illumination. In Proceedings of High-Performance Graphics (2017), pp. 2:1–2:12. 
[14] Schregle, R. Bias Compensation for Photon Maps. Computer Graphics Forum 22, 4 (2003), 729–742.
