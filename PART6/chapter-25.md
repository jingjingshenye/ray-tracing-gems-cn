# 摘要
PICA PICA 是一个综合实验项目，其中包含了随机生成场景，自学习机器人等内容。在本章中我们将详细介绍在项目使用了的一个基于实时光线追踪的渲染管线。PICA PICA 展示了光线追踪能够提升光栅化渲染器的渲染质量来逼近离线渲染中常用的路径追踪技术。

本章将详细介绍 PICA PICA 中各种渲染技术的详细设计，以及混合渲染管线的技术实现的细节，并提供实现各个渲染技术的建议。本章还提供了基于光线追踪的阴影（Shadow）以及环境光遮蔽（Ambient Occlusion）的伪代码。除此之外，本章还介绍了一种自适应的多尺度（multi-scale）平均估计量用于代替指数平均的估计方法。虽然 PICA PICA 没有使用很多纹理（texture）并且尺寸相对较小，本章介绍的各种混合渲染的方法可以在修改后用于任何 AAA 游戏。总而言之，本章将介绍给读者一个与各种艺术风格相互兼容，并能在现有基于物理的渲染器中加入光线追踪的模块化设计。

# 25.1 混合渲染器综述
PICA PICA[2, 3] 所使用的混合渲染器基于光栅化渲染管线和计算管线（compute stage），以及最近加入的光线追踪管线（ray tracing stage）[23]。图 25-1 描述了渲染的最终效果，读者可以在这里找到视频的版本[10]。图 25-2 分别展示渲染管线中的每个环节，我们可以发现整个混合管线在不同的环节根据不同的需求，考虑了不同 GPU 管线的优势，选择了不同的管线。

模块化的渲染方式是达到极致渲染效果的关键，通过各个管线之间的相互协作，利用每个管线的特性来解决每个模块的问题。与此同时，DirectX 支持在不同的管线之间分享中间渲染结果并在最后将这些结果组合到一起渲染出最终结果。此外，这样的划分方法是可扩展的，图25-2中提到的技术可以根据用户的硬件能力进行调整。例如，阴影可以使用光栅化渲染管线或光线追踪管线，反射和环境遮挡可以使用光线追踪追踪管线或使用光线行进算法（ray marched）。全局照明、透明度和半透明是 PICA PICA 项目中唯一完全需要光线追踪的功能。图 25-2 中描述的各个阶段按以下顺序执行：

1  对象空间渲染。

1.1 纹理空间对象参数化。

1.2 透明度和半透明光线追踪。

2  全局照明（漫反射相互作用）。

3 生成 G-Buffer。

4  直接阴影。

4.1  用 G-Buffer 辅助生成阴影。

4.2 阴影去噪。

5  反射。

5.1 用 G-Buffer 辅助生成反射。

5.2 用光线追踪在反射交界处生成阴影。

5.3 反射去噪。

6  直接光照。

7  反射和辐射度合并。

8  后期处理。


# 25.2 管线详细介绍
在下面的小节中，我们将分解并讨论 pica pica 混合渲染管线中的模块。我们将关注阴影、反射、环境光遮蔽、非不透明物体（transparency and translucency）和全局光照。我们将不讨论 G-buffer 或者 后处理部分，因为它们是建立在现有的[1]最好的方法之上的。

## 25.2.1 阴影
不可否认，精确的阴影可以提高图像的渲染质量。如图25-3所示，由于光线追踪阴影能完美与场景中的物体相接，并同时能处理任何尺寸的阴影，所以光线追踪阴影是一种非常好的解决方案。

实现最简单的光线追踪阴影（硬阴影）很简单：从表面向光线发射光线，如果光线击中物体，则表面处于阴影中。我们称我们的算法是混合（hybrid）的，因为它依赖于 G-Buffer 中的深度缓冲来重建像素在世界空间中的位置，并使用此位置作为阴影光线的原点。

如文献[1，21]所述，软阴影通过在锥形区域内发射光线，实现在接近地面物体接触点时过渡成硬阴影。软阴影在传递尺度和距离上优于硬阴影，更能代表真实世界的阴影。硬阴影和软阴影如图25-4所示。

使用DirectX光线追踪（DXR），基于光线追踪的阴影可以通过光线生成着色器（ray generation shader）和未命中着色器（miss shader）实现：
// code
如伪代码所示，未命中着色器有效载荷（payload）用于携带光线几何可见性信息。此外，我们使用ray_flag_skip_closest_hit_shader 来向 API 标记不需要调用命中着色器的结果，来优化 TraceRay() 函数的性能。驱动程序可以使用这些信息来相应地调度这些光线，从而最大限度地提高性能。

代码还演示了锥角函数 uniformSampleCone() 的使用，它决定了软阴影的柔和度。角度越宽，阴影越柔和，但会产生更多的噪声。发射额外的光线或者使用降噪器可以减少这种噪声。后者如图25-5所示。

为了过滤阴影，我们应用了一个基于时空方差引导过滤（SVGF）[24]的过滤器，并使用单个值来表示阴影。与一个四通道的颜色值相比，单个值的计算速度更快。为了减少由于基于时间的过滤所导致的延迟并提高整体的画面对外部输入的相应度，我们使用类似于karis[15]提出的方法，将其与一个像素值范围（pixel value bounding box clamp）相结合。我们使用基于 salvi 方差的方法[22]来计算范围的大小，其内核为 5x5 个像素。整个过程如图25-6所示。

值得注意的是，我们使用最近命中着色器（closest-hit shaders）实现阴影。阴影也可以用任何命中着色器（any-hit shader）实现，我们可以指定任意一个有效的命中为有效。由于场景中没有任何需要经过透明度测试的几何体，如植被，因此 PICA PICA 不需要任何命中着色器。

虽然我们的方法适用于不透明阴影，但对于透明阴影也可以使用类似的方法[4]。半透明渲染，尤其是在仅限于光栅化的情况下，是实时渲染中的一个难题[20]。光线追踪使新的替代方案成为可能。我们通过将常规追踪阴影的代码替换为递归光线追踪半透明表面来实现透明阴影，结果如图25-7所示。

正确地在厚介质中追踪光线[11]并不是一个简单的问题。出于性能原因，我们采用薄膜近似法 - 假设颜色在物体表面。未来的改进中，我们将考虑实现基于距离的能量吸收。

我们从任何需要计算阴影的表面向光源发射光线。如果光线命中任何不透明的表面，或者光线没有命中任何物体，我们就终止追踪。然而，如果我们撞击到一个透明的表面，我们会根据物体的颜色累积吸收，然后继续朝着光源追踪。如果所有的光都被吸收，就认为该光线没有命中，否则就认为光线命中了一个不透明的表面，计算最终的阴影值。见图25-8。

虽然我们的方法确实考虑了菲涅耳效应对界面过渡的影响，但是却忽略了焦散效应的复杂性。因此，当介质入射侧的折射率高于远侧时，Schlick 的菲涅耳近似值[25]就会失效。为了改善这一点，我们基于 Schlick 模型，使用全内反射（total internal reflection）来进行近似[16]。

与不透明光线追踪软阴影类似，我们使用改进的 SVGF 过滤器过滤透明软阴影。值得注意的是，我们只在计算直接阴影时计算透明阴影。如果其他任何渲染模块需要对光源的可见性进行采样，我们将所有表面视为不透明表面以提升性能。

## 25.2.2 反射

利用光线追踪的主要技术之一是反射。反射是渲染图像的基本组成部分。如果处理得当，反射将和场景中的对象完美相接，进而显著提高视觉逼真度。

在最近的电子游戏中，局部反射体（local reflection volume）[17]和屏幕空间反射（SSR）[27]是计算实时限制条件下的反射的两种主要方法。虽然这些技术通常可以提供足够逼真的结果，但这些方法并不健壮。当缺乏屏幕外的相关信息，或无法捕捉到复杂的相互反射（interreflection）的情况下，这些方法就会失效。如图25-9所示，光线追踪能够以一种健壮的方式实现完全动态的复杂反射。

与我们处理阴影和环境光遮蔽的方法类似，我们从 G-Buffer 提取表面位置以发射反射光线从而节省了进行主可见性测试的需要。反射缓冲为半分辨率大小，也可以认为是每四像素发射一条光线进行。由于有多个环节对本帧的反射信息进行重建和过滤使其达到完全分辨率，所以半分辨率并不是一个问题。通过同时使用空间和时间上信息，来重建丢失的局部信息，我们可以在保证算法性能的基础上仍然渲染出在视觉上令人信服的反射效果，并且我们的技术适用于任意具有不同法线，粗糙度，材料类型的不透明表面。我们最初使用的方法是将上文描述的方法与屏幕空间反射（SSR）相结合以保证性能，但最终考虑到简洁性和一致性，我们决定仅使用基于光线追踪的反射。我们认为我们的方法会更接近由路径跟踪产出的结果，原因有二。第一，经典的基于屏幕空间模糊算法需要构造特殊逻辑以避免意外模糊掉物体轮廓，但是由于我们的方法依赖随机抽样和时空过滤，所以我们不需要处理这种问题。第二，我们使用了由BRDF构造的随机路径对表面进行着色，所以表面外观更加真实。

如图 25-10 所示，反射系统有一个完整的流程。第一步，我们通过对材质进行重要性采样，根据相机的观察方向，同时考虑我们的分层BRDF，来决定光线的方向。受 Weidlich 和 Wilkie[29]的启发，我们的材料模型将多层组合成一个单一、统一和富有表现力的BRDF。该模型适用于所有照明和渲染模式，而且能量守恒，并能处理层间的菲涅尔效应。由于对整个材料采样是复杂且昂贵的，我们决定仅仅根据正太分布来进行重要性采样。一旦选择了一个微表面的法向量，我们就可以用它来计算观察向量（view vector）的反射向量来用作反射光线的方向。

由于我们每四个像素仅有一条光线，高质量的光线分布尤为重要。由于 Halton 序列易于计算，并且不管对于较多还是较少的采样都具有比较好的分布，我们使用了这个拟随机低差序列进行采样。为了使得每个像素之间都存在一定差异，我们还同时对每个像素使用了 Cranley-Patterson 旋转。
 
由于反射的方向是样本空间中的一个任意值并且服从正态分布，算法可能产生朝物体内部发射的光线，如图25-11中的蓝线所示，对于这种情况，我们可以进行对应的检测，并计算另一条反射光线。

采样材质模型最简单的方法是对等概率随机选择其中一个层并采样该层的BRDF。显然这样是浪费的 - 光滑透明的图层在大多数情况是几乎不可见的，但是当入射角为掠角（grazing angle）时占主导。为了优化采样效率，我们使用了一个基于每个层的估计可见度的概率密度函数来选择层，如图 25-12 所示。

在选择了某一层材质之后，我们通过之前提到的微表面法向采样算法来产生一条匹配材质参数的反射光线。除了反射向量之外，我们还需要对由重要性采样所取得的概率的倒数进行缩放来作为光照的贡献值。虽然多个层可能会产生相同的方向，但是我们应该关注于整个表面的采样概率，而不仅仅是表面上单个层的。因此，我们必须要将所有概率相加，使得最终的值可以代表对整个表面采样的方向，而不是对一个层的采样方向。这样做可以简化随后的重建步骤并且可以使用这个方法来表达整个材质，而不是单单一些部分。

如图 25-13 所示，是对单个光源场景进行路径追踪后得到的半分辨率反射缓冲。

如图25-14，之后，我们对半分辨率的反射缓冲使用空间过滤。虽然结果仍然有一部分噪声，但是图像的尺寸已经是全分辨率的了。与 Stachowiak [27] 和 Heitz et al. [12]的工作类似， 这步和每像素追踪16条光线情况下能降低方差的量相近。全分辨率缓冲中每个像素追踪一些光线，并对他们的命中进行加权平均以重建反射，权重的一部分使用像素的BRDF来表达材质的影响，并且除以源光线的概率分布函数（PDF）来考虑光线方向的贡献。虽然这种方法并不是无偏的，但是在实践中效果仍然比较好。

在计算反射的最后一步中，我们使用一个简单的双边滤波器（ bilateral filter ）来清理图像中残余的噪声。虽然这种过滤比较难控制，并且会过度模糊图像，但是对于高粗糙度的反射表面，我们仍然需要这种技术。与SSR相比，光线追踪不能依赖于模糊的屏幕图像来获得已经过滤过的辐射度（radiance），并且它产生的噪声比SSR要大得多，因此它需要更激进的滤波器。尽管如此，这种过滤器的效果仍然可控。我们通过估计空间重建过程中图像的方差，如图25-15所示，来调整过滤器的核（kernel）。在方差较低的情况下，我们会减小内核大小和样本计数，从而防止过度模糊图像。

由于在每帧最后我们还会使用TAA（Temporal Antialiasing），我们将能够得到一张比较清晰的图像。当观察图25-9时，切记这是每帧每四个像素追踪一根光线所得到的结果，并且这种方法适用于运动的相机和物体。

由于我们不管是平滑的还是粗糙的反射，都依赖随机采样，因此我们的方法本身就是具有噪声的。随机抽样虽然容易产生噪声，但只要有足够的样本，就可以得到物理上正确的结果。虽然我们也可以对于高粗糙度的表面，采用模糊镜面反射来取得最终结果，但是这可能导致反射的结果溢出到邻近像素。同时过滤还需要一个宽的像素足迹来产生模糊的反射，而且高频细节处仍然可能产生噪声。由于结构化走样过滤的困难性，因此非随机算法比随机算法容易产生更多的闪烁。同时，随机技术可以放大场景中的方差，尤其是对于小亮光源。因此微小的亮光源可以被检测到，并通过使用更多的偏差来处理，并渐渐将算法转向非随机方法。我们的反射算法已经朝着这种将随机采样和空间重建相结合的方向迈出了一步，今后需要在这个方向上投入更多的研究。在实践中，我们对主样本空间进行了偏移，使光线飞得更接近镜像方向，然后在过滤过程中抵消了一些偏移。

对于时间累积，一个简单的指数平滑算子（它混合在前一帧之上）是不够的。对于时间技术来说，因为重投影必须将帧之间的结果关联起来，移动尤其困难。当我们重新思考的时候，两种不同的方法首先出现在我们的脑海里。首先，我们可以使用反射体的运动矢量，这可以从混合渲染管线中的其他技术中获得。第二，反射随自己的视差移动，可以通过找到反射光线的平均长度来跟踪，并且可以通过每个像素的平均命中点重新投射。两种方法如图25-16所示。

每种方法各有其优点。如图25-16所示，运动向量适用于粗糙的曲面，但不适用于光亮的平面。另一方面，再投射命中点在地板上有效，但在曲面上无效。基于上述观察，我们可以对新生成的图像中的每个像素进行简单的统计，并使用它来选择采用哪种重投影方法。如果我们计算每个新像素的平均颜色和标准偏差，我们就可以定义一个距离度量，并使用它来衡量重投影值：
1 dist = (rgb - rgb_mean) / rgb_deviation; 
2 w = exp2(-10 * luma(dist));

最后，如karis[15]所示，我们可以使用局部像素统计来拒绝或限制重新投影的值，并强制它们适应新的分布。虽然结果并不完美，但这无疑是一种进步。虽然这会使结果产生偏差，并会产生一些闪烁，但它可以很好地清除重影，并足以满足实时场景。

## 25.2.3 环境光遮蔽
不管是在实时或者离线图形学中，环境光遮蔽（AO）都被在一般的全局光照方案失效时用来提高近景的渲染质量，并且对于具有非常少甚至没有直接阴影的地面上物体尤其的有帮助。在电子游戏中，一般预先采用离线方法或者实时使用屏幕空间信息来计算环境光遮蔽。虽然烘焙可以提供准确的信息，但是却无法处理移动的物体。基于屏幕空间信息的方法，如GTAO（Ground-truth Ambient Occlusion）和 HBAO（Horizon-Based Ambient Occlusion），虽然可以提供逼真的效果，但是却会受限于屏幕空间中含有的信息。比如当屏幕外的物体理应影响遮蔽的结果，或者物体在视锥内但是在预处理阶段被剔除了，当屏幕空间算法就会失效，渲染效果可能会显得非常不自然。

我们可以通过实时光线追踪技术来渲染高质量的环境光遮蔽效果从而摆脱存在于基于光栅化的算法中的各种限制。在 PICA PICA 中，我们生成光线来对遮蔽函数进行随机采样，其方向通过对半球面随机取样来决定，同时通过一个余弦加权分布（consie-weighted distribution）来减少噪声。除此之外，我们还对每个场景采用一个可配置的最大光线长度以在取得更好的性能的同时，提高渲染的效果。最后，我们还使用了一种和我们处理阴影时使用的类似技术来进一步进行降噪。

环境光遮蔽使用的着色器与阴影的非常类似，所以我们仅仅列出了部分代码。和阴影相似，我们通过 G-Buffer 来计算每个像素对应的世界坐标和法向量。

由于在 shadowPayload 中，miss 被初始化为 false，并且仅仅会在未命中着色器（miss shader）中设置成 true，我们可以也设置  RAY_FLAG_SKIP_CLOSEST_HIT_SHADER 来跳过命中着色器（hit shader）。最后，我们在单元半球面上生成服从余弦加权分布的采样，使用 G-Buffer 中的法向量信息来生成切线空间，得到世界坐标系中的方向向量。

图 25-17 比较了不同版本的环境光遮蔽，他们都限制了最远有效命中距离为 0.6 米。我们通过对每个像素进行1000次采样（1000 spp，sample per pixel），生成了左上方的参照图像。显然这对于实时场景来说太慢了，在 PICA PICA 中，我们每像素采样一次或两次，生成了如图 25-17 右上图中充满噪声的结果。在通过过滤之后，如左下图所示，我们得到了较好的结果。虽然 1spp 的结果没有那么锐利，但是我们降噪后的环境光遮蔽结果已经和参考结果非常接近了。

## 25.2.4 透明物体的渲染
在光栅化渲染中， 透明物体通常通过额外的渲染管线单独处理。然而在光线追踪渲染器中，无论物体的透明度如何，我们都可以使用统一的算法，正如使光线在整个场景的空气中传播一样，使光线在厚介质中传播同样可以计算正确的光照结果。如图25-18，渲染玻璃等非不透明材质中的折射效果就是一个非常典型的例子。

在光线追踪算法中，我们可以从相交测试的结果中非常容易的得到一系列介质转换的信息。图 25-19 展示了一条光线是如何从介质外部传播并穿过介质。在这个过程中，光线由于材质的物理参数特性发生折射而改变方向，这些中间信息对于渲染介质对光线的吸收和散射等高质量效果至关重要，并作为光线的一部分信息保存起来。我们将在 25.2.5 章节中描述散射的细节。

光线追踪通过记录介质的转换实现了与渲染顺序无关的 透明物体渲染，并精确的计算出含透明度物体相对其他物体的位置顺序关系。虽然对于光滑表面来说，顺序无关的折射渲染显得非常简单且直接，粗糙表面的折射可能需要额外的处理。如同图25-20所示，我们需要多次采样才能够收敛到一个没有噪声的结果。因为屏幕上很有可能有多层不一样的材质相互重叠，所以这种折射效果很难通过顺序无关的方式进行过滤。我们现有的屏幕空间的实时降噪器为了实现与顺序无关的渲染，假设屏幕上没有多层表面相互重叠。不仅如此，当场景变得复杂时，对每个像素实现顺序无关的透明度渲染会需要非常多的内存以使其可以交互。

我们结合了物体空间的光线追踪和纹理空间参数化以及积分来改善这个问题。纹理提供了一个稳定的积分空间和更可控的内存足迹（memory footprint）。对于每个物体，将物体空间映射到纹理空间也使得我们可以预测每帧光线追踪所需要的光线的数量，进而可以计算需要的开销。这些预测对于实时渲染来说是非常重要的。图 25-21 提供了一个根据需求，在进行光线追踪前生成的纹理空间映射的例子。我的方法最少需要位置和法向量信息，但是其他的额外如材质等信息也可以通过类似的方式存储起来。这可以认为是为每个物体生成了一套 G-Buffer。除此之外，实现还必须保证在展开 UV 时，没有片面相互重叠。图 25-22 展示了光线追踪的结果。

在追踪光线时，我们结合上文的参数化方法和相机的信息来生成光线的原点，并决定光线的方向。应用 Snell 定律，我们可以计算出透明光滑玻璃的折射，而毛玻璃的折射则需要应用一个基于物理的散射公式[28]，光线在遇到微表面时发生折射，并根据粗糙度在一定的立体角范围内发散。对于越是粗糙的表面，立体角的范围越大。

当光线从一种介质进入另一种介质时，我们可以使用 DXR 提供的 HitKind() 来获取光线命中了三角形的正面还是背面，进而获取介质转换的信息。

有了这些信息，我们可以改变折射的下标并准确处理介质的转换。然后，我们可以追踪一根光线，对光源进行采样，并根据Beer定律估计介质的吸收特性以调整最后的结果。我们也可以通过计算色差来估计与光线波长相关的折射。

这是一个递归的过程，并且根据不一样的性能指标，我们可以设定不一样的递归深度上限。

## 25.2.5 透光物体的渲染

图 25-23 展示了三张光线追踪透光物体的渲染结果。我们使用和处理透明物体相类似的方法，将透光物体的表面位置映射到纹理空间。图 25-24 展示了散射的过程：假设有一个光源和一个需要着色的表面，如(a)所示，我们通过(b)表面的法向量确定合法的位置。对于其中一个点来说，选取其法向量，我们可以延长该向量使其进入物体内部(c)。之后，和Christensen et al. [6]所做的工作相似，(d)我们发射方向服从均匀球面分布的光线。虽然我们可以一次性发射多条光线，但是事实上我们每帧仅发射一条。最后，我们在命中处计算光照的结果(e)，并和之前已有的结果相过渡。

如图25-25所示，我们通过时间积累（temporal accumulation）来使得结果最后收敛。由于漫反射（diffuse）光照效果本身的特点，我们没有遇到足够多的噪声，所以我们并没有再额外使用基于空间的过滤（spatial filtering）方式进行进一步降噪。由于当物体移动时，光照条件会改变，所以基于时间的过滤方式需要无效化现有的结果，并适应这种动态性。指数平均是一种简单而可行的方式。为了提高响应度和稳定性，我们使用了一个基于指数平均的自适应的基于时间的过滤算法[26]。在下一节中，我们会详细介绍这个算法，并展示如何通过控制它的滞后性来在动态的情况下重新收敛到期望结果。

## 25.2.6 全局光照
作为全局光照的一部分，添加间接光照的漫反射部分能使得场景中的物体之间显得和谐，并使得结果显得尤其的逼真。

在 PICA PICA 中，我们采用了了一种不需要预先计算的漫反射间接光照方案，同时它也不需要使用如 UV 坐标等预先计算的参数化方法。这不仅默认就提供了非常逼真的效果，而且还解放了美术的生产力，使得他们不需要思考全局光照的实现细节。

我们的方法支持静态场景，并且能够很好地响应动态场景中的变化，在若干帧之后能够得到非常高质量的结果。由于在现有硬件的条件下无法计算每个像素的全局光照并同时达到实时帧率，我们同时需要在时间和空间上进行积累。在这个项目中，我们每帧有 250,000 条光线的预算来计算漫反射全局光照。

我们在世界空间中储存一种动态分配的，叫做面元（surfel）的数据结构来达到所需要的性能标准以及画面质量。如图 25-26 所示，对于这个场景来说，如果每个面元每帧可以使用一条光线，我们最多可以使用 250,000 个面元。每个面元中存储了位置，法向量，半径以及辐照（irradiance）等信息。由于面元被存储在世界空间中，所以根据时间积累的结果不会有遮蔽问题（比如上一帧并不可见的物体在下一帧中变得可见）。由于这只是一簇的面元，我们不需要对场景做任何的参数化。对于非静态的物体，面元会记录其生成的位置在哪个物体上，并每帧动态更新其位置。

程序在启动时将分配一个数组来存储面元。在这之后，程序根据相机的位置来渐进地生成面元，如图 25-27。我们在GPU上完成之后的步骤，当有新的面元被存储进数组时，原子计数器（atomic counter）就会加一。放置面元的算法是一个需要使用G-Buffer信息的迭代过程。首先，我们将屏幕切分成16*16的区域，并分别计算每个像素的面元覆盖率。算法倾向于在覆盖率较低的地方生成新的面元。我们首先将屏幕细分成多个区域（tile），并在每个区域内找到覆盖率最低的像素作为最优的备选像素。在这之后，我们通过使用G-Buffer中的法向量和深度信息来生成新的面元，并同时在面元中记录这些信息。

需要注意的是，面元是根据概率生成的。考虑以下场景：当相机靠近一面几乎没有面元的墙时，突然间所有的像素的面元覆盖率都非常低，因此它们都开始要求生成面元。由于每个区域之间相互独立，较小的区域将生成过多的面元。因此，生成面元的启发式中考虑了像素在世界空间中的投影面积。这个过程在每帧都会被重复，如果某个局部的面元覆盖率较低时，新的面元就会被生成。不仅如此，由于我们在屏幕空间进行生成面元的操作，突然的相机或物体运动会使得第一次被见到的区域缺少漫反射全局光照。对于需要在时间上进行积累的算法来说，这种“第一帧”问题是非常常见的，并且会被用户发现。虽然PICA PICA并没有这个问题，但是根据使用场景的不同，这可能是一个需要考虑的问题。

使用面元当然也有一些缺陷。比如分辨率将受限于面元的分布，并且算法将无法捕捉高频细节。为了补偿这一点，我们在基于屏幕空间的环境光遮蔽（Screen space Ambient Occlusion）的基础上进行多次反射，并添加颜色信息[14]。虽然使用这种含有高频信息的AO使我们的算法并不完全符合理论，但是这是一种基于审美的选择来补偿缺失的高频信息。如图25-29，这种着色多频（colored multi-frequency）方法还帮助我们保持了整个像玩具一样的场景的暖色调色温。

通过在一个简单的单向路径追踪渲染器中添加额外和光源的连接来计算面元的辐照信息。对于刚刚生成的面元来说，算法会生成很多的路径来帮助结果更快的收敛。之后，路径的数量将逐渐减少，直到每帧一条。完全递归的路径追踪通常非常昂贵，对于我们的情况来说，也并不必要。通过重用上一帧的输出，我们可以将额外的反射均摊到每一帧中以充分利用时间连贯性（temporal coherence）。如图25-30所示，当路径第一次命中后，我们立刻对前一帧的结果进行采样。面元路径追踪反射结果中的间接光照来源于该次反射命中的其他面元上的信息（经过一段时间后收敛）而不是一条多次反射的路径。我们的方法相比于路径追踪来说更接近于辐照度算法（radiosity），但是对于我们以漫反射为主的场景来说，最后的视觉效果和路径追踪非常相近。

路劲追踪一般使用蒙特卡洛积分。它可以表达成一个均值估计模型（estimator），积分的结果是线性递减权重的加权平均。积分结果不变是其收敛的一个重要条件，而在我们的动态全局光照中并非如此，积分的结果随时都可能产生变化。对于可交互的路径追踪渲染器以及渐进式光照贴图烘培器来说，它们的目标是在运行足够的时间之后提供一个完全正确，没有偏差的结果，因此它们一般通过在积分结果产生变化时重置积累的结果来应对这一问题。而对于实时系统来说，一个强制重置并不可行。

由于我们无法使用蒙特卡洛方法，我们放弃了尝试完全收敛结果，而改为使用一个基于指数平均的估计模型。

Equation 1

整个公式和蒙特卡洛方法非常类似。区别在于如何定义加权参数 k。对于一个新的采样来说，指数平均一般采用一个较小的常量以缩小新的样本对整体方差的影响，进而防止输出值产生抖动。

如果新的采样没有很高的方差，那么输出自然也不会。在这种情况下，我们就可以使用一个较高的加权参数 k。由于我们的积分结果会随时间变化，我们通过另一个估计模型来评估最近短期的均值和方差，并将结果应用于主加权参数的估计中，通过这样一套方法来动态地对 k 进行估计。同时，短期（short-term）数据也帮助我们理解了对于不同的输入采样应该对应何种输出值，并进而在输出值开始偏离有效范围时，帮助提高加权参数。正如演示中所示，这种方法在实践中能够实现非常响应式的间接漫反射光照效果。

## 25.3 性能
我们在这一小节中提供了各种不一样的性能指标来度量混合渲染管线中光线追踪的不同方面。我们使用了 NVIDIA 预发售的 Turing GPU 以及驱动，渲染了图 25-32 的场景和相机角度，采集了图 25-31 中的数据。当我们在 SIGGRAPH 2018 进行展示时，PICA PICA 能够以每秒 60 帧的速度，在 1920x1080 的分辨率下运行，并且这些性能指标相对应的，使用了当时最尖端的 GPU，NVIDIA 的 Titan V（Volta）进行渲染。

## 25.4 未来
PICA PICA 项目中所使用的混合渲染管线技术使得在实时系统中渲染视觉上令人享受并非常接近光线追踪的效果成为可能。同时，尽管在每帧中，每个像素仅发射了非常少的光线，我们的结果基本没有噪声。并且由于实时光线追踪，我们可以将原有各种运行条件非常苛刻的技术替换成统一的渲染算法，进而逐步淘汰各种易于产生破绽的算法，如基于屏幕空间的光线步进，并且节省了美术调整效果的时间。即使内容创作者不是专家也可以轻易的创建逼真的视觉效果，从此写实的渲染效果可以变得唾手可得。

这是一个新的领域，实时光线追踪无疑提供了许多可能性。虽然开发者永远会要求更高性能的硬件，我们现有的硬件已经开始能够在保证高性能和帧率的情况下，提供高品质的渲染效果。如果科学地分配光线的预算，我们一定可以通过缓和渲染技术在实时条件下达到离线路径追踪渲染器的渲染质量。

# 声明
作者希望感谢 SEED 的 PICA PICA 团队。SEED 是艺电的一个技术创新研究部门。我们也同事想感谢我们在 Frostbite 和 DICE 团队的朋友，他们在我们构建混合渲染管线时和我们进行了许多非常棒的讨论和合作。不仅如此，如果没有 NVIDIA 和来自微软的 DirectX 团队的帮助，这个先驱项目也不可能完成。作者同时非常感谢 Morgan McGuire 审阅了本章节，以及 Tomas Akenine-Möller 和 Eric Haines 对本章节的建议。


图注：

图 25-1 PICA PICA 中的混合光线追踪

图 25-2 
G-Buffer（光栅化渲染）	直接阴影（光线追踪或者光栅化）	直接光照（计算管线）	反射（光线追踪或者计算管线）
全局光照（光线追踪或计算管线）	环境光遮蔽（光线追踪或计算管线）	透明或者透光材质（光线追踪或计算管线）	后处理（计算管线）

图 25-3 混合光线追踪软阴影

图 25-4 混合光线追踪阴影：硬阴影（左），过滤后的软阴影（右）

图 25-5 混合光线追踪阴影：过滤前（左），过滤后（右）

图 25-6 阴影过滤，基于 Schied et al. [24] 的工作

图 25-7 透光物体的混合光线追踪阴影

图 25-8 如何使用混合光线追踪技术来积累透光材质的阴影

图 25-9 运用混合光线追踪的反射

图 25-10 反射着色管线

图 25-11 左：反射采样  右：Cranley-Patterson rotated Halton 序列。使用 BRDF 进行的重要性采样来生成的有效的反射光线（绿色）和在地平线之下的反射光线（蓝色）的分布，均服从概率分布（折线轮廓，灰色填充区域）

图 25-12 8 帧对多层材质的采样

图 25-13 1光线/4像素情况下，使用混合光线追踪计算的反射

图 25-14 在 100% 分辨率下重建后的混合光线追踪阴影

图 25-15 反射的方差

图 25-16 左上：动作重投影；右上：相交点重投影；左下：将动作重投影和相交点重投影的结果进行平均；右下：限制结果的有效范围（clamping）

图 25-17 左上：基于光线追踪的AO（1000spp）；右上：基于混合光线追踪的AO（1spp）左下：过滤后混合光线追踪AO（1spp）；右下：GTAO

图 25-18 左：物体空间的混合光线追踪透明物体结果；右：纹理空间输出

图 25-19 在物体空间渲染光滑透明物体表面

图 25-20 在物体空间渲染粗糙透明物体表面

图 25-21 物体空间的参数化：法向量（左），位置（右）

图 25-22 使用混合光线追踪，在物体空间渲染透明物体表面。结果（左），纹理空间输出（右）

图 25-23 混合光线追踪渲染透光表面

图 25-24 光线散射过程（细节参见文字）

图 25-25 在纹理空间积累混合光线追踪的结果

图 25-26 基于面源的漫反射光照相互反射

图 25-27 面元渐进地在场景中生成

图 25-28 在屏幕空间中使用面元

图 25-29 左：颜色编码的 GTAO；中：基于面元的GI；右：同时使用基于面元的GI和颜色编码的GTAO

图 25-30 左：完整递归的路径追踪；右：递进前一帧结果的路径追踪

图 25-31 性能指标，单位：毫秒（ms）。绿色部分为 SIGGRAPH 2018 的时间

图 25-32 进行性能评测的场景

