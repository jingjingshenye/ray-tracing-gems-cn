## 第三部分：反射，折射与阴影

任何使用光线追踪的渲染都将不可避免的需要一些关于支持哪些效果的讨论。历史上，光线追踪被用来很好的处理阴影、反射和折射。但是，当你坐下来真正开始实现这一整个系统并支持这些效果时，你将遇到一些不易察觉地设计决策。本书的这一部分描述了其中一些的具体情况。

虽然光线追踪一个透明玻璃球很简单，但更复杂的模型就会变得困难起来。例如，一个简单的装水的玻璃杯呈现三种不同类型的材料界面行为：水/空气、玻璃/空气和玻璃/水。为了得到正确的折射，光线/表面的相互作用不仅需要知道被击中的界面，还需要知道另一面上有什么材料。期望一个艺术家用这些材料交接面建立一个模型是有问题的。想象一下用水填充一个玻璃杯。在第11章“嵌套材料的自动处理”中，描述了处理该问题的一种巧妙且经过实际检验的方法。

几乎所有光线跟踪程序都遇到了一个问题，那就是当凹凸贴图产生物理上不可能的曲面法向量时该怎么做。"hard if"的代码解决方案选择忽略他们，这可能会导致不连续的颜色。每一个光线跟踪器都有自己的自制trick来处理这个问题。在第12章中，"通过基于微表面的阴影函数方案解决Bump Map问题"，提出了一种简单的统计方法，并给出了一个清晰的实现。光线跟踪的屏幕空间方法使其在生成屏幕精确阴影时尤其强大，而不存在与阴影贴图相关的所有失真问题。然而，光线跟踪是否能够快到满足实时交互？第13章“光线跟踪阴影：保持实时帧速率”详细解释了如何实现这一点。

大多数简单的光线跟踪器从眼睛发出光线。通常，这些程序实际上无法产生焦散--杯中液体、游泳池和湖泊等会产生的光聚焦现象。这是因为结果充斥着噪声。但是，将光线从光源发送到环境中是生成焦散的可行方法。事实上，这甚至可以实时完成，如第14章“使用DXR的单散射介质中的光线引导体积水焦散”所述。

总之，基本的光追渲染器是相当简单的。而构建一个产品级光线跟踪渲染器需要对基本效果进行一些仔细的处理，本部分为他们的实现提供了一些有用方法。

## 11章      嵌套材料的自动处理

### 摘要

我们提出了一种新颖而简单的算法来自动处理嵌套介质体界面之间的转换，从而实现一键渲染的功能。唯一的要求是使用封闭的介质体（以光线跟踪实现，如NVIDIA RTX，确保滴水不漏的遍历和求交），并且相邻介质体不相互交叉。

### 11.1 介质体的模型化

暴力光线追踪已经成为模拟光传的核心技术，并被用于在许多大型工业渲染系统中渲染逼真的图像。对于任何基于光线追踪的渲染器，都需要处理场景中材质和几何对象的关系：

- 为了正确地模拟反射和折射，我们需要知道介质边界曲面正面和反面的折射率。请注意，这不仅需要用于具有折射特性的材料(透明.译注)，而且在反射强度由菲涅耳方程驱动的情况下也是如此(不透明但使用与折射率相关的菲涅尔方程.译注)。
- 可能需要确定体积相关的系数（体散射和吸收率），例如，当光线离开一个介质体时应用体积衰减。

因此，处理包括嵌套介质在内的体积数据是渲染工业级场景的基本要求，必须与渲染核心紧密集成。光线跟踪，即其底层的层次遍历和几何交集，总是受到浮点精度实现的限制的影响。甚至是几何数据表示，例如，使用浮点来实例化网格Transform，将会进一步引入精度问题。因此，要可靠地处理体积过渡，至少需要对体积及其周围的几何体进行仔细的建模。随后我们将区分三种情况来模拟相邻介质体。见图11.1。

![img](https://pic1.zhimg.com/v2-ec56171fb182208cf5fb600ed788df04_b.png)

11.1.1 独立边界

这种看似直截了当的方式在相邻介质体之间共享独立的表面，以清楚地描述两个（或更多）介质体之间的接口。也就是说，当两个透明对象（如玻璃和水）相遇时，一个曲面网格将取代原来的两个网格，并被赋予特殊类型。艺术家通常无法用这种方式对介质体进行建模，因为它需要手动将单个对象分割成多个子区域，这取决于哪个子区域与相邻的卷相接触。举一个充满苏打水的玻璃杯的常见例子，它包括了内部气泡和杯壁，手动细分网格是不可行的，特别是在场景是动画的情况下。该方案的另一个主要复杂之处是，每个表面都需要为正面和背面提供单独的材料，而且正/背面需要被明确定义。

注意，独立表面也可以复制，为每个介质体提供单独的封闭边界。因此，也可以避免所有繁琐的细分工作。然而，在实践中，很难迫使表面精确匹配。艺术家，或由于隐式的建模/动画/仿真软件本身可能会选择不同的细分级别，或者受制于浮点精度，相邻边界的实例转换可能略有不同。因此，需要仔细设计光线跟踪实现和渲染核心，以便能够处理此类“匹配”曲面。光线跟踪核心，包括加速结构构建，必须保证它总是报告所有“最近”的交叉点。渲染核心还必须能够按正确的顺序对交点列表进行排序。

11.1.2 添加空气间隙

第二种方法允许相邻介质体之间有一个微小的气隙，以缓解上述的大多数建模问题。不幸的是，这导致了由常见的光线跟踪实现引起的新的浮点数学问题：在生成路径的新段时，每个光线原点需要一个小的偏移量，以避免自相交。由于这一现象，当与相邻的体积边界相交时，将可能完全跳过一个（或多个）体积边界过渡。因此，必须保证气隙的大小大于这个小的偏移量。而与之相比，插入气隙的另一个主要缺点更为明显，因为气隙会显著改变渲染的外观--发生的体积传输/折射比预期的要多。见图11.2。

![img](https://pic4.zhimg.com/v2-b31e45a7c5c96a7812b77b9766d98fdb_b.png)

11.1.3 重叠介质边界

为了避免前面两个方案的缺点，我们可以强制相邻的介质体稍微重叠。见图11.3。不幸的是，第三种方法也将引入一个新问题：路径/体积交叉点的顺序和数量将不再正确。施密特等人通过为每个介质体分配优先级来解决这一问题。这需要艺术家明确的额外劳动，对于复杂的设置这可能是乏味的，尤其是在做动画时。

请注意，除了上述三种方案外，还有另一种值得注意的特殊情况：完全嵌套/封闭的介质体被完全包含在另一个介质体中。参见图11.1中的彩色对象。这些通常会切断周围的体积。一些渲染实现还可能允许重叠或嵌套介质的混合。显然，这并没有帮助降低实现的复杂性，正如前面提到的，在进入或离开相邻介质时仍然存在问题。这些转换更难检测和正确处理，因为允许路径同时通过“多个”介质。因此，我们的贡献是针对一次只能处理单个介质的渲染器。

在下文中，我们描述了一种新的算法，当使用重叠体边界的方法时，在没有手动优先级分配的情况下，恢复路径/体积交叉点的正确顺序。作为Iray渲染系统的一部分，它已在生产中成功使用了十多年。

### 11.2 算法

我们的算法管理当前所有活动材料的堆栈。每次光线照射到一个表面上，我们将表面的材料push到堆栈上，并确定入射和边界背面的材料。基本思想是，如果材料在堆栈上被引用奇数次，则当前是进入介质体；如果材料被引用偶数次，则当前是退出介质体。由于我们假设边界overlapping，堆栈处理还需要确保路径上的两个曲面中只有一个实际报告为体积边界。我们通过检查进入当前材质后是否进入了其他材质来过滤第二个边界来实现这一点。为了提高效率，我们为每个堆栈元素存储两个标志：一个标志指示堆栈元素是否是引用材料的最顶端，另一个标志指示堆栈元素是奇数或偶数引用。一旦对该点的着色完成，再继续追踪时，我们需要区分三种情况：

1. 对于反射，我们从堆栈中弹出top标记元素，并更新相同材质上一个实例的top标记。
2. 对于决定离开新push材料的传输（如折射），我们不仅需要弹出top标记的元素，还需要删除以前对该材料的引用。
3. 对于相同的材料边界（将被跳过）和确定进入新材料的传输，我们保持堆栈不变。

请注意，在分割路径轨迹的情况下，例如跟踪多条光泽反射光线，每个生成的光线需要有一个单独的堆栈。

如果摄像机本身位于某介质内，则需要构建一个反映该介质嵌套状态的初始堆栈。要填充堆栈，可以从场景的边界框外递归地跟踪光线到相机位置。

11.2.1 实现

在下面我们将介绍介质堆栈算法实现的代码片段。一个重要的实现细节是，如果摄像机包含在一个介质中，那么堆栈可能永远不会是空的，并且最初应该包含人工“真空”材料（标记为奇数和top的）或从预处理阶段复制的初始堆栈。

如程序清单11.1所示，介质堆栈的数据结构需要保存存储堆栈元素的奇偶性和最顶层属性的材料索引和标志。此外，我们需要能够访问场景中的材质，并假设它们可以进行比较。实际上，对材料index进行比较就足够了。

![img](https://pic2.zhimg.com/v2-112e501946134d3d8688a028064eee4d_b.png)

当光线照射到物体表面时，我们将材料index push到堆栈上，并确定实际的入射和出射index。在索引相同的情况下，光线跟踪代码应该跳过该边界。变量leaving material表示跨越边界将离开该材质，这需要在Pop()中实现。参见程序清单11.2。

![img](https://pic4.zhimg.com/v2-6ac7f4e71a2343c1ea6f8ae86163d597_b.png)

当渲染代码继续进行光线跟踪时，我们需要从堆栈中弹出材质，如程序清单11.3所示。对于传输事件，只有在设置了“离开材料”时才会调用此函数，在这种情况下，将从堆栈中删除两个元素。

![img](https://pic1.zhimg.com/v2-db79358c04bd998734fd3c66bab88a94_b.png)

11.3 局限性

我们的算法将永远丢弃它遇到的重叠的第二个边界。因此，实际相交的几何图形取决于光线轨迹，并将根据原点而变化。特别是，从光到相机的路径和从相机到光的路径将是不相同的，这将对双向光传输算法（如双向路径跟踪）的方法造成误差。一般来说，缺乏明确的边界删除顺序可能导致删除重叠的“错误”部分。例如，对于首先进入玻璃的光线，水将从图11.3中的玻璃碗中划出重叠区域。如果overlapping部分足够小，这将不会导致可见的失真。但是，如果一个场景具有较大的重叠，例如，图11.4和11.5中漂浮的部分淹没的冰块，则产生的误差可能很大（尽管对最终结果的影响不好辨明）。因此，应在不会破坏算法或损害沿路径的后续体积交互的正确性的前提下尽量避免预期的交叉体积。

![img](https://pic4.zhimg.com/v2-0fbc53fecec2bb51aafbf007d66cc42f_b.png)

通过分配优先级对介质体施加明确的顺序将以失去易用性为代价来解决这种问题。这个解决方案有其局限性，因为易用性对于许多用户来说是必不可少的，例如那些依赖于现成的资产库、灯光设置和材料而不知道任何技术细节的用户。

对每个路径设置堆栈会增加空间需求，因此高度并行的渲染系统可能需要小心地限制介质堆栈大小。虽然能够提供捕获堆栈溢出的实现，但除了避免崩溃之外，它什么也做不了。

References 

[1] Keller, A., Wachter, C., Raab, M., Seibert, D., van Antwerpen, D., ¨ Korndorfer, J., and Kettner, L. ¨ The Iray Light Transport Simulation and Rendering System. arXiv, https://arxiv.org/abs/1705.01263, 2017. 

[2] Pharr, M. Special Issue On Production Rendering and Regular Papers. ACM Transactions on Graphics 37, 3 (2018). 

[3] Schmidt, C. M., and Budge, B. Simple Nested Dielectrics in Ray Traced Images. Journal of Graphics Tools 7, 2 (2002), 1–8. 

[4] Woo, A., Pearce, A., and Ouellette, M. It’s Really Not a Rendering Bug, You See... IEEE Computer Graphics and Applications 16, 5 (Sept 1996), 21–25.