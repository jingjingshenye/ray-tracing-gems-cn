# 使用屏幕空间光子映射技术渲染焦散

## 摘要

**光子映射**（photon mapping, PM）是一种全局光照技术，它模拟由光源发射出的光子在场景中传输的过程，以渲染**焦散**（caustic）和其他间接光照效果。此章节介绍了一种借助**硬件光线追踪**（hardware ray tracing）和**屏幕空间降噪器**（screen-space denoiser），在屏幕空间实时渲染焦散的光子映射技术。

## 30.1 引言

光子映射是由 Wann Jensen [2] 提出的一种全新的全局光照技术。它使用光子去计算**光路传输**（light transportation），以获取全局光照效果和焦散等光线聚集效果。尽管传统的光子映射技术善于渲染焦散，它却难以应用到实时游戏领域。这是因为光子映射需要非常多的光子参与计算才能得到平滑的结果，这意味着每一帧都需要进行大量的光线追踪计算。

McGuire 和 Luebke 提出了**图像空间光子映射**（image-space photon mapping，ISPM）技术，把光子映射应用到实时领域。ISPM 把光子存储为**世界空间**（world space）下的一个**体**（volume）。因为这些光子的数目要远远小于真实世界中的光子数目，它们必须要以某种方式被传播（散射）。在本章中，我们把光子存储为一个屏幕空间下的**纹素**（texel），而不是世界空间下的体或者**面元**（surfel）。这个方法被称为**屏幕空间光子映射**（screen-space photon mapping，SSPM）。尽管这个方法有一定的局限性，它在渲染焦散方面仍存在一些优点。

焦散是强烈光线作用的结果。如果一个光子穿过两个**折射率**（indice of refraction，IOR）不同的介质，如从空气到玻璃或者从空气到水，光子将进行折射，其方向有可能会改变。折射的光子可能会被**散射**（scatter）或被**集聚**（concentrate）在一起。这些集聚的光子会产生焦散效果。另外，**反射**（reflection）也会产生焦散。反射的光子也可能多次反射于周边的物体后被集聚到一起。图30-1展示了一些焦散的例子；右上图中，黄色的焦散是由环的反射产生的。

图30-1. 由屏幕空间光子映射生成的焦散效果，每个场景使用了2k × 2k的光子。从左上到右下，使用的场景依次是：Conference Room、Ring and Bunny on Conference Room (Ring & Bunny)、Bistro 以及 Connell Box。稍后在表30-2中展示其性能评估。

要注意的是，在本章中，屏幕空间光子映射仅仅被用于渲染焦散，而不是整个场景的全局光照。若想获取全局光照，其他经过优化的通用“大型”**光子收集**（photon-gathering）技术[1,3]可能提供更好的解决方案。

## 30.2 概述

光子映射一般有两个阶段：**光子图生成**（photon map generation）与**渲染**（rendering）。本文中，我们把它分为三个阶段：

* 光子发射和光子追踪（散射）。
* 光子收集（去噪）。
* 使用光子图进行照明。

第一阶段是**光子发射**（photon emission）与**光子追踪**（photon tracing），我们将在30.3.1节中详述。在DirectX Raytracing（DXR）中，**光线生成着色器**（ray generation shader）的每条光线对应一个光子。当一个光子从光源出发，到达一个不透明的表面时，将被存储在屏幕空间中。
需要注意的是，光子的发射和追踪并不是屏幕空间操作。与**屏幕空间反射**（screen-space reflections）技术相同，在使用DXR时，光线追踪在世界空间而不是屏幕空间中执行。光线追踪过后，光子被存储在屏幕空间中。**渲染目标纹理**（render target texture）将存储这些光子，而后作为光子图使用。因为光子被存储为屏幕空间纹理的一个纹素了，光子图中出现了带有噪点的焦散（如图30-4中左部所示）。因此，第二阶段，即**光子收集**（photon gathering）或称**光子降噪**（photon denoising）阶段将用来平滑光子图，之后在30.3.2节中详述。光子全部被收集之后，我们会得到一个平滑的光子图。最后，光子图将被用在直接光照的流程里，这部分在30.3.3节中详述。

注意，这里假设使用的是一个延迟渲染的系统。延迟渲染中的
**G缓冲**（G-buffer）包含一个**深度缓冲**（depth buffer）或**粗糙度缓冲**（roughness buffer），用来在屏幕空间存储和收集光子。

## 30.3 实现

### 30.3.1 光子发射和光子追踪

本节中使用的符号汇总在表30-1中。

#### 30.3.1.1 光子发射

光子在世界空间中被发射和追踪。发射的光子拥有**颜色**（color）、**强度**（intensity）和**方向**（direction）属性。当光子最终在世界空间下停止时，只保留它的颜色和强度属性。因为一个像素中需要存储多个光子，为节省空间，不再保留光子入射时的方向。光子的**辐射通量**（flux），即颜色和强度（不包括方向），将被保存在像素中。

对于一个点光源来说，光子从光源所在的位置发射出去。公式1展示了光子的发射辐射通量$Φ_{e}$

公式（1）

这里的$p_{w}$和$p_{h}$是光子光线的尺寸，$l_{e}$是来自光源的光线的**辐射率**（radiance）：

公式（2）

对于一个方向光光源来说，公式是与点光源类似的。但是不同于点光源，方向光光源发射的光子将扩散到整个场景，且不会有任何衰减。由于每个光子对应于多条光线进行追踪，减少光子的浪费对于同时提升质量和性能来说非常重要。为了减少对光子的浪费，Jensen[2]使用**投影图**（projection map）将光子集聚在重要区域。投影图是从光源观察的有关几何图形的图，它包含从光源的特定方向观察的几何图形的存在性信息。

为了简单和高效，对于方向光，我们使用一个名为**投影体**（projection volume）的包围盒。其目的与 Jensen 投影图中的单元格（cell）保持相同。投影体是一个其中存在可以生成焦散的物体的包围盒，如图30-2中的体V所示。通过将盒子投射到方向光的反方向，我们可以得到一个矩形的光区域（light area），如图中区域A。如果我们只发射光子到投影体中，光子可以集聚在产生方向光焦散的物体上。此外，我们可以控制光线的数量，以获得一致的质量或一致的性能，即恒定光子发射面积或恒定射线追踪的数目。

图30-2。 左：投影体V和对应的光区域A。右：投影体被放置在包含透明物体的桌子上。(a)通过透明物体产生焦散的光线用橙色标出。(b)直接光对应的光子用红色标出。这些光子将被丢弃不用。(c)在投影体之外，不会发射光线。

（该划线自然段原文中的表述译者没有理解，望指教）
<u>对于与投影体V一同创建的光区域A的分辨率，$p_{w}$$p_{h}$是光线生成着色器的尺寸。光线生成着色器的每条光线携带一个从A区域发射的光子，由于每个光子对应于光区域的一部分，每个光子对应光区域$a_{l}$的面积为$1/(p_{w}p_{h})$。方向光的发射辐射通量为：</u>

公式3

这里应该注意，$a_{l}$是世界空间单位中光区域A的面积。

#### 30.3.1.2 光子追踪

光子发射后，在世界空间下进行光子追踪，直到到达追踪的最大深度或击中**不透明**（opaque）表面。更详细地说，当光子在追踪过程中击中某个物体后，它会评估物体表面的材质信息。
如果被击中的表面足够不透明，光子就会停止，并对场景深度进行评估，以检查表面是否会将光子存储在屏幕空间中。
如果没有物体被击中，或者光子的场景深度超过了存储在深度缓冲中的深度，光子将被丢弃。
因为光子在通过透明物体时能量会衰减，因此当光子强度小到可以忽略不计时，光子也会停止。

图30-2中的红色光线对应于直接光，不会存储。从直接光照中储存光子是多余的，因为我们在单独的**通道**（pass）中处理直接光。在去噪阶段，去除所有直接光可能会在阴影边缘产生一些伪影，但这些伪影并不十分明显。

因为通过透明物体跟踪光线在光子映射中不是一个特殊的部分，所以我跳过了这些细节。

简而言之，光子不被储存的条件有四种：
1。
光子的强度很小。
2. 
要存储的位置在屏幕之外。
3.
光子深度超过了存储的深度缓冲值。
4. 
光子是直接光照的一部分。

产生光子的代码在光子发射的函数在rt.hlsl文件的rayGenMain中。

#### 30.3.1.3 存储光子

屏幕空间光子映射过程的一个重要部分是将一个光子压缩成一个像素。这对于给定的一个像素来说可能是错误的，但是作为一个整体，能量是守恒的。压缩的光子被存储在单个像素中，而不是分散（散射）到邻近像素中。光子被存储后，在接下面的降噪阶段，像素中的光子将被散射到它的邻近像素（即，从邻近像素收集光子）。

世界空间单位下，像素的面积$a_{p}$为：

公式4

这里的$w$和$h$是屏幕的相对宽度和高度；$θ_{x}$和$θ_{y}$是**视野**（field-of-view，FOV）的$x$和$y$方向上的相对角度。$d$是从观察点到像素在世界空间下的距离。

因为$Φ_{e}$表示的不是辐射度，而是辐射通量，光子必须转化为适当的辐射度。要存储在像素中的辐射度$l_{p}$为：

公式5

请注意，屏幕空间光子映射的优点之一是光子在存储时可以使用**眼矢量**（eye vector）。这意味着光子从表面的BRDFs中估计出镜面颜色和漫反射颜色。

图30-3为去噪前不同光子数的比较。存储光子实现的代码在光子发射函数storePhoton，PhotonEmission.rt.hlsl中。

图30-3。从左上到右下，500 × 500, 1000 × 1000, 2000 × 2000, 和 3000 × 3000 光子，Bistro场景，使用方向光。


### 30.3.2 光子收集

传统的光线追踪使用了多种技术以得到一个精确且平滑的结果。为了得到实时的效果，在屏幕空间收集光子最简单的方法之一是使用NVIDIA GamesWorks Ray Tracing技术中的**反射降噪器**（reflection denosier）。使用这个反射降噪器，我们可以把光子看作是使用了一些trick的反射。

这个降噪器接受相机数据（矩阵）、深度缓存、粗糙度缓存、以及法向量缓存作为输入。它使用相机矩阵和深度构造了一个世界空间，接着根据法向量和粗糙度收集临近像素的反射值。要记住，这个降噪器会接受一个记录了从像素到反射碰撞点的碰撞距离的缓存。

在光子降噪器中，碰撞距离将作为最后一个碰撞点到像素的距离，在根本上与上面描述的反射一致。然而，不同于反射的是，光子图并不需要**锐利**（sharp）的效果。由于较小的命中距离可以防止光子映射模糊，所以我将这个距离固定到一个适当的值，该值根据场景的不同而变化。

法向和粗糙度是光子去噪器的**静态值**（static value）。一方面，如果使用物体的原始法线，光子就不能很好地聚集。另一方面，粗糙度是去噪反射的一个关键部分，因此理想情况下应该保留原始值。经过一些实验，我将法线设置为像素到相机的方向，粗糙度设置为0.07左右的某个值。这些值可能会因不同场景或降噪器的不同版本而更改。我将粗糙度设置为场景全局模糊度的参数，并根据碰撞距离调整每个光子的模糊度。

去噪前后对比见图30-4。这里总结了光子降噪器的降噪参数：

* 法线：从像素到相机的方向
* 粗糙度：恒定值；0.07在我测试时表现很好。
* 碰撞距离：用最小值和最大值夹紧的最后跟踪距离。在我的场景中，300和2000分别是最小值和最大值。我建议你构造一个适合你场景的距离函数。

图30-4。左：降噪前。右：降噪后。上：Ring & Bunny场景。下：Connell Box场景。两个场景都使用了来自点光源的2000×2000光子渲染的。

具体实现见PhotonGather.cpp中的PhotonGather::GameworksDenoiser类。

注意，虽然使用GameWorks的降噪器器效果很好，但它只是去噪的优秀方法之一。由于GameWorks的光线追踪降噪器是对光线追踪的双边滤波，读者可能想要实现一种专门针对光子噪声的降噪器，以获得微调的空间和更高的效率。


除了GameWorks去噪器外，PhotonGather.cpp中的PhotonGather::BilateralDenoiser类中还提供了一种双边光子降噪器。双边光子消噪器由两部分组成：**向下采样**（downsampling）光子图和降噪光子图。**近深度**（near-depth）表面将采用下采样光子图（这里不讨论；参见代码中的详细注释)。双边滤波也有很好的参考文献[3,6]。

### 30.3.3 光照

光子图的光照很简单。光子图光照很接近于延迟渲染系统中的屏幕空间光照。光子图中的光子被认为是像素的附加光。图30-5的中图展示了只显示光子图的结果。

图30-5。左：未使用SPPM。中：只显示光子图。右：两者结合。上：Bistro场景。下：Cornell Box场景。

## 30.4 结果

借助Microsoft's DXR和NVIDIA's RTX，可以实现具有一定局限性的实时焦散渲染。图30-1展示了焦散的渲染结果，表30-2列出了渲染的性能评估。所有的性能评估都包括降噪所花费的时间。该降噪器的成本约为3~5毫秒。注意，使用反射降噪器并不是光子去噪的最佳解决方案。

表30-2。图30-1中场景在具有1920×1080像素的GeForce RTX 2080 Ti上渲染的性能评估。
所有的度量单位都是以毫秒为单位的，括号中的数字是与不使用SPPM时的差距。

表内翻译：场景（Scene）、不使用SPPM（No SPPM）、光子（Photons）

本章所有的图片均使用虚幻引擎4渲染；然而，附带的代码是基于NVIDIA的Falcor引擎的。
不使用SSPM和使用1k×1k光子的SSPM的计时结果对Bistro场景没有什么区别，因为这个场景中的物体非常多。

### 30.4.1 局限与未来工作

虽然屏幕空间光子映射是实时可行的，但也存在一些局限性，也会产生一些**伪迹**（artifacts）。
首先，由于在将像素写入光线追踪着色器中的缓冲区时缺少**原子操作**（atomic operation），因此当两个着色器线程同时写入相同的像素时，可能会丢失一些值。
其次，由于靠近屏幕截锥体的近深度像素对于光子来说分辨率太高，当相机接近焦散表面时，光子不能很好地收集。这可以通过使用其他模糊技术和自定义降噪器器来改进。

### 30.4.2 深度缓冲区中的透明对象

在本章中，透明对象与不透明对象一样被绘制到深度缓冲区。透明物体的半透明效果是通过光线追踪来实现的，从这些物体的表面开始。虽然这不是延迟渲染系统的通常实现方法，但是对于渲染焦散来说，它也有一些优点和缺点。当它们被绘制在深度缓冲时，焦散光子可以存储在透明物体上。然而，除了透明的物体，我们看不到焦散。这个局限性可以在图30-1中的Cornell Box场景中看出。

### 30.4.3 实际应用

如前所述，一些光子在写入缓冲区时会丢失。此外，光子的数量远远少于我们在现实世界中所需要的。一些光子在去噪过程中变得模糊不清。为了实用和艺术的目的，可以增加额外的焦散强度。
这在物理上是不正确的，但会弥补一些光子的损失。注意，本章所列图中并没有采用额外的强度来显示精确的结果。

还有一件事要讨论一下。如你所知，由反射和折射产生的焦散应该在有限的条件下使用。当前的方法选择透明迭代作为主循环。产生反射焦散的光线在每个透明循环中生成。30.5节中描述了这部分实现。如果场景受反射焦散比折射影响更大，反射迭代可能更合适作为主循环。

## 30.5 代码

下面的伪代码对应于光子发射和光子跟踪，包括如何存储光子。完整的代码可以在PhotonEmission.rt.hlsl中找到。

代码中的注释：
// 为点光源初始化光线
// 光线追踪
// 被光线击中的表面信息的结果
// 存储条件在30.3.1.2节中描述。
// 如何存储一个光子在30.3.1.3节中描述。
// 如果表面粗糙度足够低，光子就会被反射。

## 参考文献