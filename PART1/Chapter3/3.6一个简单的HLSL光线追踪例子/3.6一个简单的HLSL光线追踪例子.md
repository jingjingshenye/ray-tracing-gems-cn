要提供一个更具体的示例来说明这在实践中是如何工作的，请考虑下面的HLSL片段。它定义了一个由ShadowRay()函数实例化的光线，如果光线被遮挡，它返回0，否则返回1(即，即“阴影射线”)。ShadowRay()只能在光线生成时，或者closest-hit,或者miss着色器中调用TraceRay().从逻辑上讲，光线预设情况是被阻挡的，除非miss着色器执行的时侯，我们才知道光线时没有被阻挡的。这允许我们避免执行最近命中的着色器(RAY_FLAG_SKIP_CLOSEST_HIT_SHADER)，并在发生遮挡的任何碰撞之后停止执行(RAY_FLAG_ACCEPT_FIRST_HIT_AND_END_SEARCH)。

```c++
1 RaytracingAccelerationStructure scene; // C++ puts built BVH here
2
3 struct ShadowPayload { // Define a ray payload
4   float isVisible; // 0: occluded, 1: visible
5 };
6
7 [shader("miss")] // Define miss shader #0
8 void ShadowMiss(inout ShadowPayload pay) {
9   pay.isVisible = 1.0f; // We miss ! Ray unoccluded
10 }
11
12 [shader("anyhit")] // Add to hit group #0
13 void ShadowAnyHit(inout ShadowPayload pay,
14  BuiltInTriangleIntersectionAttributes attrib) {
15      if ( isTransparent( attrib, PrimitiveIndex() ) )
16          IgnoreHit(); // Skip transparent hits
17 }
18
19 float ShadowRay( float3 orig, float3 dir, float minT, float maxT ) {
20  RayDesc ray = { orig, minT, dir, maxT }; // Define our new ray.
21  ShadowPayload pay = { 0.0f }; // Assume ray is occluded
22  TraceRay( scene,
23      (RAY_FLAG_SKIP_CLOSEST_HIT_SHADER |
24      RAY_FLAG_ACCEPT_FIRST_HIT_AND_END_SEARCH),
25      0xFF, 0, 1, 0, ray, pay ); // Hit group 0; miss 0
26  return pay.isVisible; // Return ray payload
27 }
```
注意，这段代码使用一个自定义编写的isTransparent()函数来查询材质系统(基于基元ID和碰撞点)来执行alpha测试。

在地方，阴影光线可以很容易地从其他着色器投射;例如，一个简单的环境遮挡渲染器可能看起来如下:

```c++
1 Texture2D<float4> gBufferPos, gBufferNorm; // Input G-buffer
2 RWTexture2D<float4> output; // Output AO buffer
3
4 [shader("raygeneration")]
5 void SimpleAOExample() {
6   uint2 pixelID = DispatchRaysIndex().xy; // What pixel are we on?
7   float3 pos = gBufferPos[ pixelID ].rgb; // AO rays from where?
8   float3 norm = gBufferNorm[ pixelID ].rgb; // G-buffer normal
9   float aoColor = 0.0f;
10  for (uint i = 0; i < 64; i++) // Use 64 rays.
11      aoColor += (1.0f/64.0f) * ShadowRay(pos, GetRandDir(norm), 1e-4);
12  output[ pixelID ] = float4( aoColor, aoColor, aoColor, 1.0f );
13 }
```
GetRandDir()函数返回一个随机选择的方向，这方向是在一个单元半球通过表面法线和1e−4 minT值定义的（1e−4 minT是用来传递给ShadowRay()的值，是用于避免与自己相交的一个偏移量（self-intersections)(可以参考第六章更高级的内容)。


